package lpsolvelib;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.DoubleBuffer;
import java.nio.IntBuffer;
import lpsolvehash.hashtable;
import lpsolvemipbb.BBrec;
import lpsolveutils.LLrec;
/**
 * JNA Wrapper for library <b>LpSolveLib</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class LpSolveLibLibrary implements Library {
	public static final String JNA_LIBRARY_NAME = "LpSolveLib";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(LpSolveLibLibrary.JNA_LIBRARY_NAME);
	static {
		Native.register(LpSolveLibLibrary.JNA_LIBRARY_NAME);
	}
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_RANGE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_DURINGBB = (int)128;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INVERSE_GLPKLU = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SWITCH_TO_PRIMAL = (int)20;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LOSTFEAS = (int)23;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int CRASH_NONBASICBOUNDS = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ITERATE_MINORRETRY = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_DYNAMIC = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_EMPS = (int)14;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSCOLUMNS = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ISSEMI = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int EQ = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int GE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_FRACTIONSELECT = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_BOUNDFLIP = (int)512;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_OF = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int FR = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final String libnameBLAS = (String)"myBLAS";
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MAX_RULESWITCH = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NOTRUN = (int)-1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MAJORVERSION = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_MATLAB = (int)10;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_GAMS = (int)6;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEF_PSEUDOCOSTUPDATES = (int)7;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_LAGCONTRACT = (double)0.90;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_MEAN = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ISREAL = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_PROBEFIX = (int)2048;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NOMEMORY = (int)-2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_SCILAB = (int)12;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_USERWEIGHT = (int)31;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_SCALINGEPS = (double)1.0e-02;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_WORKING = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCAN_NORMALVARS = (int)(1 + 4);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ACTION_REBASE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_PSEUDOCOSTMODE = (int)64;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_Unknown = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_IMPLIEDFREE = (int)512;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_EQUILIBRATE = (int)64;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_PERFORMANCE = (int)4096;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int BRANCH_DEFAULT = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_DEFAULT = (int)(2 + 4);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_MILPBETTER = (int)512;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_RELAXED = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_FUTURE2 = (int)6;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_FUTURE1 = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_COLFIXDUAL = (int)131072;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_MPSX = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_COLDOMINATE = (int)16384;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_LASTMASKMODE = (int)(524288 - 1);
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_PSEUDOCOSTRESTART = (double)0.15;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int XLIVERSION = (int)12;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_PRIMAL_DUAL = (int)(1 + 8);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_LINDEP = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_PROJECTED = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_LINEAR = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_HYBRID = (int)64;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_Phase1_DUAL = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int BB_GUB = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_AUTOPARTIAL = (int)256;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ACTION_RECOMPUTE = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEF_PARTIALBLOCKS = (int)10;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEF_LAGMAXITERATIONS = (int)100;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_OMATRIX = (int)11;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NEUTRAL = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_FORCEFULL = (int)8192;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_SPARSER = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_NONE = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_EPSMACHINE = (double)2.22e-16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int UNBOUNDED = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_OCTAVE = (int)13;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NOBFP = (int)-3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_BRANCHREVERSEMODE = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INVERSE_NONE = (int)-1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INVERSE_LUMOD = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double SCALEDINTFIXRANGE = (double)1.6;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_MILPSTRATEGY = (int)1024;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INITSOL_SHIFTZERO = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NORMAL = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int USERABORT = (int)6;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_REDUCEMIP = (int)64;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSOBJNAME = (int)-1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_NEGRANGE = (double)-1.0e+06;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEF_TIMEDREFACT = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_RHSPERTURB = (int)256;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_PRIMAL_PRIMAL = (int)(1 + 4);
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_EPSPIVOT = (double)2.0e-07;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ProductionPARAM = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MINORVERSION = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_MILPFEASIBLE = (int)128;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_BREADTHFIRSTMODE = (int)4096;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INITSOL_USEZERO = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PROCBREAK = (int)11;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_STRATEGYMASK = (int)(8 - 1);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_TEST_RELGAP = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LE = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ACTION_REPRICE = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_PARTIAL = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSROWS = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double PRICER_RANDFACT = (double)0.1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ACTION_ITERATE = (int)64;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ACTION_REINVERT = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_SetPacking = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double MIN_TIMEPIVOT = (double)5.0e-02;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_INFEASIBLE = (int)32;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_MIP_GAP = (double)1.0e-11;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSNEGOBJCONST = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ISSOS = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_DELTA = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OMIT_FIXED = (int)64;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCAN_ARTIFICIALVARS = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int RUNNING = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ITERATE_MINORMAJOR = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INVERSE_ETAPFI = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OPTIMAL = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_IMPLIEDSLK = (int)65536;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_CONSTRAINT = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MAX_STALLCOUNT = (int)12;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_PRIMALFALLBACK = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_GUBMODE = (int)512;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int BFPVERSION = (int)12;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_AUTOMULTIPLE = (int)512;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_ROWSONLY = (int)512;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_EQ = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_Phase1_PRIMAL = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_USERBREAK = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_MATHPROG = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_GeneralMIP = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_NONE = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_KNAPSACK = (int)128;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEF_MAXSINGULARITIES = (int)10;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEVEX_MINVALUE = (double)0.000;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_GeneralREAL = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_SetCover = (int)9;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALEMODEL_GEOMETRIC = (int)(0 + 4 + 128);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ISGUB = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_DEPTHFIRSTMODE = (int)128;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double MIN_SCALAR = (double)1.0e-10;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_WEIGHTREVERSEMODE = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ChvatalPARAM = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int EPS_LOOSE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCAN_USERVARS = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int BB_SOS = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PROCFAIL = (int)10;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SUBOPTIMAL = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_KnapsackBIN = (int)7;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICER_DANTZIG = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_BOUNDS = (int)262144;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_PRESOLVE = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int IMPROVE_THETAGAP = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NUMFAILURE = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEVEX_RESTARTLIMIT = (double)1.0e+09;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int FULL = (int)6;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SEVERE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MAT_START_SIZE = (int)10000;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_EPSDUAL = (double)1.0e-09;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_LPEQUAL = (int)32;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_GEOMETRIC = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int UNKNOWNERROR = (int)-5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_GAPSELECT = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_EMPTY = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_RESTARTMODE = (int)2048;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_AGGREGATE = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_PSEUDONONINTSELECT = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_GE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int CRASH_NONE = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_HARRISTWOPASS = (int)4096;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DELTAROWALLOC = (int)100;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_LEGACYLP = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int IMPROVE_DUALFEAS = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_DUAL_DUAL = (int)(2 + 8);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_GUB = (int)32;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INVERSE_LUSOL = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEF_MAXPRESOLVELOOPS = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int IMPROVE_DEFAULT = (int)(2 + 4);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_MAX = (int)10;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_ITERATION = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int IMPROVE_BBSIMPLEX = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MAX_MINITUPDATES = (int)60;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_LE = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_REDUCEGCD = (int)1024;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_COLS = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double MAX_SCALAR = (double)1.0e+10;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_STRONGINIT = (int)32768;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_MULTIPLE = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LoosePARAM = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_PERTURB = (double)1.0e-05;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ACTION_ACTIVE = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int FATHOMED = (int)14;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_CHSIGN = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_NONE = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_UNDEFINED = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_NUMFAILURE = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final String MPSVARMASK = (String)"%-8s";
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSBOUNDS = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int BB_SC = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ITERATE_MAJORMAJOR = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int IMPROVE_NONE = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_MERGEROWS = (int)32768;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_MILPEQUAL = (int)256;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int USE_ALLVARS = (int)(16 + 32);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALEMODEL_EQUILIBRATED = (int)(0 + 1 + 128);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int TIMEOUT = (int)7;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_DYNAMIC = (int)64;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEF_MAXRELAX = (int)7;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int USE_NONBASICVARS = (int)32;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_KnapsackINT = (int)6;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_CURTISREID = (int)7;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_MILPOPTIMAL = (int)2048;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_SENSDUALS = (int)1048576;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICER_FIRSTINDEX = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_OFMIN = (int)(4 + 1);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int CRASH_LEASTDEGENERATE = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_NONE = (int)-1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_MAXTYPE = (int)(8 - 1);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_OFMAX = (int)(4 + 2);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SWITCH_TO_DUAL = (int)21;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_TEST_WT = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_STALLING = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEF_OBJINBASIS = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MIN_REFACTFREQUENCY = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_QUADRATIC = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_LPBETTER = (int)64;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DOUBLEROUND = (double)0.0e-02;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NOFEASFOUND = (int)13;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_LAGACCEPT = (double)1.0e-03;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALEMODEL_ARITHMETIC = (int)(0 + 3 + 128);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LINEARSEARCH = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_TEST_WE = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_ROWS = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_COLUMNCHECK = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ACTION_NONE = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OriginalPARAM = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SINGULAR_BASIS = (int)22;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_INCUMBENT = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_EPSINT = (double)1.0e-07;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int FEASFOUND = (int)12;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_RCOSTFIXING = (int)16384;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEF_BB_LIMITLEVEL = (int)-50;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_INTEGERS = (int)128;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int RELEASE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int RESIZEFACTOR = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int BRANCH_AUTOMATIC = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_DUAL_PRIMAL = (int)(2 + 4);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MATRIXERROR = (int)24;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_DUALLIMIT = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICER_LASTOPTION = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_INACTIVE = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_Phase2_PRIMAL = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ISSOSTEMPINT = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LoadLanguageLib = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICER_STEEPESTEDGE = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_PSEUDOFEASSELECT = (int)(5 + 8);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_FIRSTSELECT = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INFEASIBLE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_GUB = (int)10;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEF_SCALINGLIMIT = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSSOS = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_CPLEXLP = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_GeneralINT = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_INVERT = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPS_FREE = (int)(2 << 2);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_LPFEASIBLE = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_GeneralBIN = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MAX_FRACSCALE = (int)6;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_PROBEREDUCE = (int)4096;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double LIMIT_ABS_REL = (double)10.0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCAN_SLACKVARS = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_S = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_R = (int)9;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DATAIGNORED = (int)-4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_ZIMPL = (int)7;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALEMODEL_DYNAMIC = (int)((0 + 4 + 128) + 64);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_TEST_NE = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_USERSELECT = (int)7;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEGENERATE = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int RANDSCALE = (int)100;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSRANGES = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_GREEDYMODE = (int)32;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int BUILD = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ISINTEGER = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_RANDOMIZE = (int)128;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_LOGARITHMIC = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_COLSONLY = (int)1024;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int IMPROVE_INVERSE = (int)(1 + 4);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_RANGESELECT = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSIBM = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICER_DEVEX = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_AUTODUALIZE = (int)32;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_TRUENORMINIT = (int)16384;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int BRANCH_FLOOR = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSRHS = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_PSEUDOCOSTSELECT = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_ACTIVE = (int)-1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_ROWDOMINATE = (int)8192;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSFIXED = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int FULLYBOUNDEDSIMPLEX = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int USE_BASICVARS = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_RANDOMIZEMODE = (int)256;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INVERSE_ACTIVE = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWTYPE_RELAX = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_STRATEGYMASK = (int)(4 + 8 + 16 + 32 + 64 + 128 + 256 + 512 + 1024 + 2048 + 4096 + 8192 + 16384);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSFREE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_NONE = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int CRITICAL = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int BRANCH_CEILING = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int IMPORTANT = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final String MPSVALUEMASK = (String)"%12g";
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_PSEUDORATIOSELECT = (int)6;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVED = (int)9;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int BB_REAL = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SIMPLEX_Phase2_DUAL = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_EPSSOLUTION = (double)1.0e-05;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LoadInverseLib = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPS_NEGOBJCONST = (int)(8 << 2);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INITSOL_ORIGINAL = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DETAILED = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_DYNAMICMODE = (int)1024;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_DEFAULT = (int)(1 | 4);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_LOOPLEFT = (int)1024;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_ADAPTIVE = (int)32;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double MIN_STABLEPIVOT = (double)5.0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int BB_INT = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_LPFML = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_LOSTFEAS = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_TEST_BE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_EXTREME = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int CRASH_MOSTFEASIBLE = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ActivePARAM = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_INITPSEUDOCOST = (int)8192;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_TEST_BT = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DELTACOLALLOC = (int)100;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ACTION_TIMEDREINVERT = (int)32;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int INVERSE_LEGACY = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ROWCLASS_Objective = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_EPSPRIMAL = (double)1.0e-10;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int DEF_MAXPIVOTRETRY = (int)10;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LANGUAGE_AMPL = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int libBLAS = (int)2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_ELIMEQ2 = (int)256;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int EPS_TIGHT = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCAN_ALLVARS = (int)(2 + 1 + 4);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCAN_PARTIALBLOCK = (int)8;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MSG_LPOPTIMAL = (int)16;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int NODE_AUTOORDER = (int)8192;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_POWER2 = (int)32;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ACTION_RESTART = (int)255;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALEMODEL_CURTISREID = (int)(7 + 128 + 32);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRICE_LOOPALTERNATE = (int)2048;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSUNDEF = (int)-4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OF_HEURISTIC = (int)4;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_DUALS = (int)524288;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_INFINITE = (double)1.0e+30;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int PRESOLVE_SOS = (int)32;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int EPS_DEFAULT = (int)0;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSNAME = (int)-3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPS_IBM = (int)(4 << 2);
	/** <i>native declaration : lp_lib.h</i> */
	public static final int MPSOBJSENSE = (int)-2;
	/** <i>native declaration : lp_lib.h</i> */
	public static final double DEF_EPSVALUE = (double)1.0e-12;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int EPS_BAGGY = (int)3;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int IMPROVE_SOLUTION = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int ANTIDEGEN_FIXEDVARS = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int EPS_MEDIUM = (int)1;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int SCALE_DYNUPDATE = (int)256;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int LAG_SINGULARLIMIT = (int)5;
	/** <i>native declaration : lp_lib.h</i> */
	public static final int OMIT_NONFIXED = (int)128;
	/**
	 * -------------------------------------------------------------------------<br>
	 * <i>native declaration : lp_lib.h:2898</i>
	 */
	public interface WINAPI extends Callback {
		int apply(lprec lp, Pointer userhandle);
	};
	/** <i>native declaration : lp_lib.h:2899</i> */
	public interface WINAPI2 extends Callback {
		void apply(lprec lp, Pointer userhandle, Pointer buf);
	};
	/** <i>native declaration : lp_lib.h:2900</i> */
	public interface WINAPI3 extends Callback {
		void apply(lprec lp, Pointer userhandle, int message);
	};
	/** <i>native declaration : lp_lib.h:2901</i> */
	public interface WINAPI4 extends Callback {
		int apply(lprec lp, Pointer userhandle, int message);
	};
	/**
	 * -------------------------------------------------------------------------<br>
	 * <i>native declaration : lp_lib.h:2903</i>
	 */
	public interface WINAPI5 extends Callback {
		byte apply(lprec lp, DoubleByReference column);
	};
	/** <i>native declaration : lp_lib.h:2904</i> */
	public interface WINAPI6 extends Callback {
		byte apply(lprec lp, int count, DoubleByReference column, IntByReference rowno);
	};
	/** <i>native declaration : lp_lib.h:2905</i> */
	public interface WINAPI7 extends Callback {
		byte apply(lprec lp, DoubleByReference row, int constr_type, double rh);
	};
	/** <i>native declaration : lp_lib.h:2906</i> */
	public interface WINAPI8 extends Callback {
		byte apply(lprec lp, int count, DoubleByReference row, IntByReference colno, int constr_type, double rh);
	};
	/** <i>native declaration : lp_lib.h:2907</i> */
	public interface WINAPI9 extends Callback {
		byte apply(lprec lp, DoubleByReference row, int con_type, double rhs);
	};
	/** <i>native declaration : lp_lib.h:2908</i> */
	public interface WINAPI10 extends Callback {
		int apply(lprec lp, Pointer name, int sostype, int priority, int count, IntByReference sosvars, DoubleByReference weights);
	};
	/** <i>native declaration : lp_lib.h:2909</i> */
	public interface WINAPI11 extends Callback {
		int apply(lprec lp, DoubleByReference column);
	};
	/** <i>native declaration : lp_lib.h:2911</i> */
	public interface WINAPI12 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2912</i> */
	public interface WINAPI13 extends Callback {
		byte apply(lprec lp, int colnr);
	};
	/** <i>native declaration : lp_lib.h:2913</i> */
	public interface WINAPI14 extends Callback {
		byte apply(lprec lp, int rownr);
	};
	/** <i>native declaration : lp_lib.h:2914</i> */
	public interface WINAPI15 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2915</i> */
	public interface WINAPI16 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2916</i> */
	public interface WINAPI17 extends Callback {
		void apply(PointerByReference plp);
	};
	/** <i>native declaration : lp_lib.h:2917</i> */
	public interface WINAPI18 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2918</i> */
	public interface WINAPI19 extends Callback {
		byte apply(lprec lp, IntByReference bascolumn, byte nonbasic);
	};
	/** <i>native declaration : lp_lib.h:2919</i> */
	public interface WINAPI20 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2920</i> */
	public interface WINAPI21 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2921</i> */
	public interface WINAPI22 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2922</i> */
	public interface WINAPI23 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2923</i> */
	public interface WINAPI24 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2924</i> */
	public interface WINAPI25 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2926</i> */
	public interface WINAPI26 extends Callback {
		byte apply(lprec lp, int colnr, DoubleByReference column);
	};
	/** <i>native declaration : lp_lib.h:2927</i> */
	public interface WINAPI27 extends Callback {
		int apply(lprec lp, int colnr, DoubleByReference column, IntByReference nzrow);
	};
	/** <i>native declaration : lp_lib.h:2928</i> */
	public interface WINAPI28 extends Callback {
		int apply(lprec lp, int rownr);
	};
	/** <i>native declaration : lp_lib.h:2929</i> */
	public interface WINAPI29 extends Callback {
		double apply(lprec lp, int rownr, int count, DoubleByReference primsolution, IntByReference nzindex);
	};
	/** <i>native declaration : lp_lib.h:2930</i> */
	public interface WINAPI30 extends Callback {
		byte apply(lprec lp, DoubleByReference constr);
	};
	/** <i>native declaration : lp_lib.h:2931</i> */
	public interface WINAPI31 extends Callback {
		byte apply(lprec lp, DoubleByReference rc);
	};
	/** <i>native declaration : lp_lib.h:2932</i> */
	public interface WINAPI32 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2933</i> */
	public interface WINAPI33 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2934</i> */
	public interface WINAPI34 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2935</i> */
	public interface WINAPI35 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2936</i> */
	public interface WINAPI36 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2937</i> */
	public interface WINAPI37 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2938</i> */
	public interface WINAPI38 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2939</i> */
	public interface WINAPI39 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2940</i> */
	public interface WINAPI40 extends Callback {
		byte apply(lprec lp, DoubleByReference lambda);
	};
	/** <i>native declaration : lp_lib.h:2941</i> */
	public interface WINAPI41 extends Callback {
		double apply(lprec lp, int colnr);
	};
	/** <i>native declaration : lp_lib.h:2942</i> */
	public interface WINAPI42 extends Callback {
		int apply(lprec lp, int orig_index);
	};
	/** <i>native declaration : lp_lib.h:2944</i> */
	public interface WINAPI43 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2945</i> */
	public interface WINAPI44 extends Callback {
		double apply(lprec lp, int rownr, int colnr);
	};
	/** <i>native declaration : lp_lib.h:2946</i> */
	public interface WINAPI45 extends Callback {
		double apply(lprec lp, int matindex, byte isrow, byte adjustsign);
	};
	/** <i>native declaration : lp_lib.h:2947</i> */
	public interface WINAPI46 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2948</i> */
	public interface WINAPI47 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2949</i> */
	public interface WINAPI48 extends Callback {
		double apply(lprec lp, byte absolute);
	};
	/** <i>native declaration : lp_lib.h:2950</i> */
	public interface WINAPI49 extends Callback {
		int apply(lprec lp, byte getabssize);
	};
	/** <i>native declaration : lp_lib.h:2951</i> */
	public interface WINAPI50 extends Callback {
		byte apply(lprec lp, byte isrow);
	};
	/** <i>native declaration : lp_lib.h:2952</i> */
	public interface WINAPI51 extends Callback {
		void apply(lprec lp, byte isrow, byte use_names);
	};
	/** <i>native declaration : lp_lib.h:2953</i> */
	public interface WINAPI52 extends Callback {
		int apply(lprec lp, Pointer varname, byte isrow);
	};
	/** <i>native declaration : lp_lib.h:2954</i> */
	public interface WINAPI53 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2955</i> */
	public interface WINAPI54 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2956</i> */
	public interface WINAPI55 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2957</i> */
	public interface WINAPI56 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2958</i> */
	public interface WINAPI57 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2959</i> */
	public interface WINAPI58 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2960</i> */
	public interface WINAPI59 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2961</i> */
	public interface WINAPI60 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2962</i> */
	public interface WINAPI61 extends Callback {
		int apply(lprec lp, int lp_index);
	};
	/** <i>native declaration : lp_lib.h:2965</i> */
	public interface WINAPI62 extends Callback {
		void apply(lprec lp, IntByReference blockcount, IntByReference blockstart, byte isrow);
	};
	/** <i>native declaration : lp_lib.h:2966</i> */
	public interface WINAPI63 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2967</i> */
	public interface WINAPI64 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2968</i> */
	public interface WINAPI65 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2969</i> */
	public interface WINAPI66 extends Callback {
		byte apply(lprec lp, DoubleByReference pv);
	};
	/** <i>native declaration : lp_lib.h:2970</i> */
	public interface WINAPI67 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2971</i> */
	public interface WINAPI68 extends Callback {
		byte apply(lprec lp, DoubleByReference clower, DoubleByReference cupper, IntByReference updatelimit);
	};
	/** <i>native declaration : lp_lib.h:2972</i> */
	public interface WINAPI69 extends Callback {
		byte apply(lprec lp, PointerByReference constr);
	};
	/** <i>native declaration : lp_lib.h:2973</i> */
	public interface WINAPI70 extends Callback {
		byte apply(lprec lp, PointerByReference rc);
	};
	/** <i>native declaration : lp_lib.h:2974</i> */
	public interface WINAPI71 extends Callback {
		byte apply(lprec lp, PointerByReference lambda);
	};
	/** <i>native declaration : lp_lib.h:2975</i> */
	public interface WINAPI72 extends Callback {
		byte apply(lprec lp, PointerByReference pv);
	};
	/** <i>native declaration : lp_lib.h:2976</i> */
	public interface WINAPI73 extends Callback {
		byte apply(lprec lp, PointerByReference objfrom, PointerByReference objtill);
	};
	/** <i>native declaration : lp_lib.h:2977</i> */
	public interface WINAPI74 extends Callback {
		byte apply(lprec lp, PointerByReference objfrom, PointerByReference objtill, PointerByReference objfromvalue, PointerByReference objtillvalue);
	};
	/** <i>native declaration : lp_lib.h:2978</i> */
	public interface WINAPI75 extends Callback {
		byte apply(lprec lp, PointerByReference duals, PointerByReference dualsfrom, PointerByReference dualstill);
	};
	/** <i>native declaration : lp_lib.h:2979</i> */
	public interface WINAPI76 extends Callback {
		byte apply(lprec lp, PointerByReference var);
	};
	/** <i>native declaration : lp_lib.h:2980</i> */
	public interface WINAPI77 extends Callback {
		double apply(lprec lp, int rownr);
	};
	/** <i>native declaration : lp_lib.h:2981</i> */
	public interface WINAPI78 extends Callback {
		double apply(lprec lp, int rownr);
	};
	/** <i>native declaration : lp_lib.h:2982</i> */
	public interface WINAPI79 extends Callback {
		int apply(lprec lp, int rownr, DoubleByReference row, IntByReference colno);
	};
	/** <i>native declaration : lp_lib.h:2983</i> */
	public interface WINAPI80 extends Callback {
		byte apply(lprec lp, int rownr, DoubleByReference row);
	};
	/** <i>native declaration : lp_lib.h:2985</i> */
	public interface WINAPI81 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2986</i> */
	public interface WINAPI82 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2987</i> */
	public interface WINAPI83 extends Callback {
		byte apply(lprec lp, DoubleByReference objfrom, DoubleByReference objtill);
	};
	/** <i>native declaration : lp_lib.h:2988</i> */
	public interface WINAPI84 extends Callback {
		byte apply(lprec lp, DoubleByReference objfrom, DoubleByReference objtill, DoubleByReference objfromvalue, DoubleByReference objtillvalue);
	};
	/** <i>native declaration : lp_lib.h:2989</i> */
	public interface WINAPI85 extends Callback {
		byte apply(lprec lp, DoubleByReference duals, DoubleByReference dualsfrom, DoubleByReference dualstill);
	};
	/** <i>native declaration : lp_lib.h:2990</i> */
	public interface WINAPI86 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2991</i> */
	public interface WINAPI87 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2992</i> */
	public interface WINAPI88 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2993</i> */
	public interface WINAPI89 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2995</i> */
	public interface WINAPI90 extends Callback {
		NativeLong apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2996</i> */
	public interface WINAPI91 extends Callback {
		long apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2997</i> */
	public interface WINAPI92 extends Callback {
		long apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:2998</i> */
	public interface WINAPI93 extends Callback {
		double apply(lprec lp, int colnr);
	};
	/** <i>native declaration : lp_lib.h:2999</i> */
	public interface WINAPI94 extends Callback {
		int apply(lprec lp, int colnr);
	};
	/** <i>native declaration : lp_lib.h:3000</i> */
	public interface WINAPI95 extends Callback {
		double apply(lprec lp, int index);
	};
	/** <i>native declaration : lp_lib.h:3001</i> */
	public interface WINAPI96 extends Callback {
		double apply(lprec lp, int index);
	};
	/** <i>native declaration : lp_lib.h:3002</i> */
	public interface WINAPI97 extends Callback {
		int apply(lprec lp, int colnr);
	};
	/** <i>native declaration : lp_lib.h:3003</i> */
	public interface WINAPI98 extends Callback {
		byte apply(lprec lp, DoubleByReference var);
	};
	/** <i>native declaration : lp_lib.h:3004</i> */
	public interface WINAPI99 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3005</i> */
	public interface WINAPI100 extends Callback {
		byte apply(lprec lp, DoubleByReference guessvector, IntByReference basisvector);
	};
	/** <i>native declaration : lp_lib.h:3006</i> */
	public interface WINAPI101 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3007</i> */
	public interface WINAPI102 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3008</i> */
	public interface WINAPI103 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3009</i> */
	public interface WINAPI104 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3010</i> */
	public interface WINAPI105 extends Callback {
		byte apply(lprec lp, int testmask);
	};
	/** <i>native declaration : lp_lib.h:3011</i> */
	public interface WINAPI106 extends Callback {
		byte apply(lprec lp, int colnr);
	};
	/** <i>native declaration : lp_lib.h:3012</i> */
	public interface WINAPI107 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3013</i> */
	public interface WINAPI108 extends Callback {
		byte apply(lprec lp, int rownr, int mask);
	};
	/** <i>native declaration : lp_lib.h:3014</i> */
	public interface WINAPI109 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3015</i> */
	public interface WINAPI110 extends Callback {
		byte apply(lprec lp, DoubleByReference values, double threshold);
	};
	/** <i>native declaration : lp_lib.h:3016</i> */
	public interface WINAPI111 extends Callback {
		byte apply(lprec lp, int colnr);
	};
	/** <i>native declaration : lp_lib.h:3017</i> */
	public interface WINAPI112 extends Callback {
		byte apply(lprec lp, double value);
	};
	/** <i>native declaration : lp_lib.h:3018</i> */
	public interface WINAPI113 extends Callback {
		byte apply(lprec lp, int column);
	};
	/** <i>native declaration : lp_lib.h:3019</i> */
	public interface WINAPI114 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3020</i> */
	public interface WINAPI115 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3021</i> */
	public interface WINAPI116 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3022</i> */
	public interface WINAPI117 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3023</i> */
	public interface WINAPI118 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3024</i> */
	public interface WINAPI119 extends Callback {
		byte apply(lprec lp, int colnr);
	};
	/** <i>native declaration : lp_lib.h:3025</i> */
	public interface WINAPI120 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3026</i> */
	public interface WINAPI121 extends Callback {
		byte apply(lprec lp, int testmask);
	};
	/** <i>native declaration : lp_lib.h:3027</i> */
	public interface WINAPI122 extends Callback {
		byte apply(lprec lp, int rule);
	};
	/** <i>native declaration : lp_lib.h:3028</i> */
	public interface WINAPI123 extends Callback {
		byte apply(lprec lp, int testmask);
	};
	/** <i>native declaration : lp_lib.h:3029</i> */
	public interface WINAPI124 extends Callback {
		byte apply(lprec lp, int testmask);
	};
	/** <i>native declaration : lp_lib.h:3030</i> */
	public interface WINAPI125 extends Callback {
		byte apply(lprec lp, int scaletype);
	};
	/** <i>native declaration : lp_lib.h:3031</i> */
	public interface WINAPI126 extends Callback {
		byte apply(lprec lp, int colnr);
	};
	/** <i>native declaration : lp_lib.h:3032</i> */
	public interface WINAPI127 extends Callback {
		byte apply(lprec lp, int colnr);
	};
	/** <i>native declaration : lp_lib.h:3033</i> */
	public interface WINAPI128 extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3034</i> */
	public interface WINAPI129 extends Callback {
		void apply(IntByReference majorversion, IntByReference minorversion, IntByReference release, IntByReference build);
	};
	/** <i>native declaration : lp_lib.h:3036</i> */
	public interface WINAPI130 extends Callback {
		void apply(lprec lp, int columns);
	};
	/** <i>native declaration : lp_lib.h:3037</i> */
	public interface WINAPI131 extends Callback {
		byte apply(lprec lp, Pointer filename);
	};
	/** <i>native declaration : lp_lib.h:3038</i> */
	public interface WINAPI132 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3039</i> */
	public interface WINAPI133 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3040</i> */
	public interface WINAPI134 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3041</i> */
	public interface WINAPI135 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3042</i> */
	public interface WINAPI136 extends Callback {
		void apply(lprec lp, int columns);
	};
	/** <i>native declaration : lp_lib.h:3043</i> */
	public interface WINAPI137 extends Callback {
		void apply(lprec lp, Pointer str);
	};
	/** <i>native declaration : lp_lib.h:3044</i> */
	public interface WINAPI138 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3045</i> */
	public interface WINAPI139 extends Callback {
		void apply(lprec lp, LpSolveLibLibrary.lphandle_intfunc newctrlc, Pointer ctrlchandle);
	};
	/** <i>native declaration : lp_lib.h:3046</i> */
	public interface WINAPI140 extends Callback {
		void apply(lprec lp, LpSolveLibLibrary.lphandleint_intfunc newnode, Pointer bbnodehandle);
	};
	/** <i>native declaration : lp_lib.h:3047</i> */
	public interface WINAPI141 extends Callback {
		void apply(lprec lp, LpSolveLibLibrary.lphandleint_intfunc newbranch, Pointer bbbranchhandle);
	};
	/** <i>native declaration : lp_lib.h:3048</i> */
	public interface WINAPI142 extends Callback {
		void apply(lprec lp, LpSolveLibLibrary.lphandlestr_func newlog, Pointer loghandle);
	};
	/** <i>native declaration : lp_lib.h:3049</i> */
	public interface WINAPI143 extends Callback {
		void apply(lprec lp, LpSolveLibLibrary.lphandleint_func newmsg, Pointer msghandle, int mask);
	};
	/** <i>native declaration : lp_lib.h:3053</i> */
	public interface WINAPI144 extends Callback {
		byte apply(lprec lp, Pointer filename, Pointer info);
	};
	/** <i>native declaration : lp_lib.h:3054</i> */
	public interface WINAPI145 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3055</i> */
	public interface WINAPI146 extends Callback {
		byte apply(lprec lp, Pointer filename, Pointer options);
	};
	/** <i>native declaration : lp_lib.h:3056</i> */
	public interface WINAPI147 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3057</i> */
	public interface WINAPI148 extends Callback {
		byte apply(lprec lp, int rows, int columns);
	};
	/** <i>native declaration : lp_lib.h:3058</i> */
	public interface WINAPI149 extends Callback {
		byte apply(lprec lp, byte turnon);
	};
	/** <i>native declaration : lp_lib.h:3059</i> */
	public interface WINAPI150 extends Callback {
		void apply(lprec lp, int anti_degen);
	};
	/** <i>native declaration : lp_lib.h:3060</i> */
	public interface WINAPI151 extends Callback {
		int apply(lprec lp, int basisPos, int enteringCol);
	};
	/** <i>native declaration : lp_lib.h:3061</i> */
	public interface WINAPI152 extends Callback {
		byte apply(lprec lp, IntByReference bascolumn, byte nonbasic);
	};
	/** <i>native declaration : lp_lib.h:3062</i> */
	public interface WINAPI153 extends Callback {
		void apply(lprec lp, int mode);
	};
	/** <i>native declaration : lp_lib.h:3063</i> */
	public interface WINAPI154 extends Callback {
		void apply(lprec lp, int bb_maxlevel);
	};
	/** <i>native declaration : lp_lib.h:3064</i> */
	public interface WINAPI155 extends Callback {
		void apply(lprec lp, int bb_floorfirst);
	};
	/** <i>native declaration : lp_lib.h:3065</i> */
	public interface WINAPI156 extends Callback {
		void apply(lprec lp, int bb_rule);
	};
	/** <i>native declaration : lp_lib.h:3066</i> */
	public interface WINAPI157 extends Callback {
		byte apply(lprec lp, Pointer filename);
	};
	/** <i>native declaration : lp_lib.h:3067</i> */
	public interface WINAPI158 extends Callback {
		byte apply(lprec lp, int colnr, byte must_be_bin);
	};
	/** <i>native declaration : lp_lib.h:3068</i> */
	public interface WINAPI159 extends Callback {
		byte apply(lprec lp, int colnr, double lower, double upper);
	};
	/** <i>native declaration : lp_lib.h:3069</i> */
	public interface WINAPI160 extends Callback {
		void apply(lprec lp, byte tighten);
	};
	/** <i>native declaration : lp_lib.h:3070</i> */
	public interface WINAPI161 extends Callback {
		void apply(lprec lp, byte break_at_first);
	};
	/** <i>native declaration : lp_lib.h:3071</i> */
	public interface WINAPI162 extends Callback {
		void apply(lprec lp, double break_at_value);
	};
	/** <i>native declaration : lp_lib.h:3072</i> */
	public interface WINAPI163 extends Callback {
		byte apply(lprec lp, int colnr, DoubleByReference column);
	};
	/** <i>native declaration : lp_lib.h:3073</i> */
	public interface WINAPI164 extends Callback {
		byte apply(lprec lp, int colnr, int count, DoubleByReference column, IntByReference rowno);
	};
	/** <i>native declaration : lp_lib.h:3074</i> */
	public interface WINAPI165 extends Callback {
		byte apply(lprec lp, int colnr, Pointer new_name);
	};
	/** <i>native declaration : lp_lib.h:3075</i> */
	public interface WINAPI166 extends Callback {
		byte apply(lprec lp, int rownr, int con_type);
	};
	/** <i>native declaration : lp_lib.h:3076</i> */
	public interface WINAPI167 extends Callback {
		void apply(lprec lp, byte debug);
	};
	/** <i>native declaration : lp_lib.h:3077</i> */
	public interface WINAPI168 extends Callback {
		void apply(lprec lp, double epsb);
	};
	/** <i>native declaration : lp_lib.h:3078</i> */
	public interface WINAPI169 extends Callback {
		void apply(lprec lp, double epsd);
	};
	/** <i>native declaration : lp_lib.h:3079</i> */
	public interface WINAPI170 extends Callback {
		void apply(lprec lp, double epsel);
	};
	/** <i>native declaration : lp_lib.h:3080</i> */
	public interface WINAPI171 extends Callback {
		void apply(lprec lp, double epsint);
	};
	/** <i>native declaration : lp_lib.h:3081</i> */
	public interface WINAPI172 extends Callback {
		byte apply(lprec lp, int epslevel);
	};
	/** <i>native declaration : lp_lib.h:3082</i> */
	public interface WINAPI173 extends Callback {
		void apply(lprec lp, double epsperturb);
	};
	/** <i>native declaration : lp_lib.h:3083</i> */
	public interface WINAPI174 extends Callback {
		void apply(lprec lp, double epspivot);
	};
	/** <i>native declaration : lp_lib.h:3084</i> */
	public interface WINAPI175 extends Callback {
		byte apply(lprec lp, int colnr);
	};
	/** <i>native declaration : lp_lib.h:3085</i> */
	public interface WINAPI176 extends Callback {
		void apply(lprec lp, int improve);
	};
	/** <i>native declaration : lp_lib.h:3086</i> */
	public interface WINAPI177 extends Callback {
		void apply(lprec lp, double infinite);
	};
	/** <i>native declaration : lp_lib.h:3087</i> */
	public interface WINAPI178 extends Callback {
		byte apply(lprec lp, int colnr, byte must_be_int);
	};
	/** <i>native declaration : lp_lib.h:3088</i> */
	public interface WINAPI179 extends Callback {
		void apply(lprec lp, byte lag_trace);
	};
	/** <i>native declaration : lp_lib.h:3089</i> */
	public interface WINAPI180 extends Callback {
		byte apply(lprec lp, int colnr, double value);
	};
	/** <i>native declaration : lp_lib.h:3090</i> */
	public interface WINAPI181 extends Callback {
		byte apply(lprec lp, Pointer lpname);
	};
	/** <i>native declaration : lp_lib.h:3091</i> */
	public interface WINAPI182 extends Callback {
		byte apply(lprec lp, int row, int column, double value);
	};
	/** <i>native declaration : lp_lib.h:3092</i> */
	public interface WINAPI183 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3093</i> */
	public interface WINAPI184 extends Callback {
		void apply(lprec lp, int max_num_inv);
	};
	/** <i>native declaration : lp_lib.h:3094</i> */
	public interface WINAPI185 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3095</i> */
	public interface WINAPI186 extends Callback {
		void apply(lprec lp, byte absolute, double mip_gap);
	};
	/** <i>native declaration : lp_lib.h:3096</i> */
	public interface WINAPI187 extends Callback {
		byte apply(lprec lp, int multiblockdiv);
	};
	/** <i>native declaration : lp_lib.h:3097</i> */
	public interface WINAPI188 extends Callback {
		void apply(lprec lp, double negrange);
	};
	/** <i>native declaration : lp_lib.h:3098</i> */
	public interface WINAPI189 extends Callback {
		byte apply(lprec lp, int colnr, double value);
	};
	/** <i>native declaration : lp_lib.h:3099</i> */
	public interface WINAPI190 extends Callback {
		void apply(lprec lp, double obj_bound);
	};
	/** <i>native declaration : lp_lib.h:3100</i> */
	public interface WINAPI191 extends Callback {
		byte apply(lprec lp, DoubleByReference row);
	};
	/** <i>native declaration : lp_lib.h:3101</i> */
	public interface WINAPI192 extends Callback {
		byte apply(lprec lp, int count, DoubleByReference row, IntByReference colno);
	};
	/** <i>native declaration : lp_lib.h:3102</i> */
	public interface WINAPI193 extends Callback {
		void apply(lprec lp, byte obj_in_basis);
	};
	/** <i>native declaration : lp_lib.h:3103</i> */
	public interface WINAPI194 extends Callback {
		byte apply(lprec lp, Pointer filename);
	};
	/** <i>native declaration : lp_lib.h:3104</i> */
	public interface WINAPI195 extends Callback {
		void apply(lprec lp, Pointer stream);
	};
	/** <i>native declaration : lp_lib.h:3105</i> */
	public interface WINAPI196 extends Callback {
		byte apply(lprec lp, int blockcount, IntByReference blockstart, byte isrow);
	};
	/** <i>native declaration : lp_lib.h:3106</i> */
	public interface WINAPI197 extends Callback {
		void apply(lprec lp, int piv_rule);
	};
	/** <i>native declaration : lp_lib.h:3107</i> */
	public interface WINAPI198 extends Callback {
		void apply(lprec lp, byte dodual);
	};
	/** <i>native declaration : lp_lib.h:3108</i> */
	public interface WINAPI199 extends Callback {
		void apply(lprec lp, int presolvemode, int maxloops);
	};
	/** <i>native declaration : lp_lib.h:3109</i> */
	public interface WINAPI200 extends Callback {
		void apply(lprec lp, int print_sol);
	};
	/** <i>native declaration : lp_lib.h:3110</i> */
	public interface WINAPI201 extends Callback {
		byte apply(lprec lp, DoubleByReference clower, DoubleByReference cupper, IntByReference updatelimit);
	};
	/** <i>native declaration : lp_lib.h:3111</i> */
	public interface WINAPI202 extends Callback {
		byte apply(lprec lp, int rownr, double value);
	};
	/** <i>native declaration : lp_lib.h:3112</i> */
	public interface WINAPI203 extends Callback {
		byte apply(lprec lp, int rownr, double deltavalue);
	};
	/** <i>native declaration : lp_lib.h:3113</i> */
	public interface WINAPI204 extends Callback {
		void apply(lprec lp, DoubleByReference rh);
	};
	/** <i>native declaration : lp_lib.h:3114</i> */
	public interface WINAPI205 extends Callback {
		byte apply(lprec lp, int rownr, DoubleByReference row);
	};
	/** <i>native declaration : lp_lib.h:3115</i> */
	public interface WINAPI206 extends Callback {
		byte apply(lprec lp, int rownr, int count, DoubleByReference row, IntByReference colno);
	};
	/** <i>native declaration : lp_lib.h:3116</i> */
	public interface WINAPI207 extends Callback {
		byte apply(lprec lp, int rownr, Pointer new_name);
	};
	/** <i>native declaration : lp_lib.h:3117</i> */
	public interface WINAPI208 extends Callback {
		void apply(lprec lp, double scalelimit);
	};
	/** <i>native declaration : lp_lib.h:3118</i> */
	public interface WINAPI209 extends Callback {
		void apply(lprec lp, int scalemode);
	};
	/** <i>native declaration : lp_lib.h:3119</i> */
	public interface WINAPI210 extends Callback {
		byte apply(lprec lp, int colnr, byte must_be_sc);
	};
	/** <i>native declaration : lp_lib.h:3120</i> */
	public interface WINAPI211 extends Callback {
		void apply(lprec lp, byte maximize);
	};
	/** <i>native declaration : lp_lib.h:3121</i> */
	public interface WINAPI212 extends Callback {
		void apply(lprec lp, int simplextype);
	};
	/** <i>native declaration : lp_lib.h:3122</i> */
	public interface WINAPI213 extends Callback {
		void apply(lprec lp, int limit);
	};
	/** <i>native declaration : lp_lib.h:3123</i> */
	public interface WINAPI214 extends Callback {
		void apply(lprec lp, NativeLong sectimeout);
	};
	/** <i>native declaration : lp_lib.h:3124</i> */
	public interface WINAPI215 extends Callback {
		void apply(lprec lp, byte trace);
	};
	/** <i>native declaration : lp_lib.h:3125</i> */
	public interface WINAPI216 extends Callback {
		byte apply(lprec lp, int colnr, double value);
	};
	/** <i>native declaration : lp_lib.h:3126</i> */
	public interface WINAPI217 extends Callback {
		byte apply(lprec lp, int colnr, int branch_mode);
	};
	/** <i>native declaration : lp_lib.h:3127</i> */
	public interface WINAPI218 extends Callback {
		byte apply(lprec lp, DoubleByReference weights);
	};
	/** <i>native declaration : lp_lib.h:3128</i> */
	public interface WINAPI219 extends Callback {
		void apply(lprec lp, int verbose);
	};
	/** <i>native declaration : lp_lib.h:3129</i> */
	public interface WINAPI220 extends Callback {
		byte apply(lprec lp, Pointer filename);
	};
	/** <i>native declaration : lp_lib.h:3130</i> */
	public interface WINAPI221 extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3131</i> */
	public interface WINAPI222 extends Callback {
		byte apply(lprec lp, Pointer col_string);
	};
	/** <i>native declaration : lp_lib.h:3132</i> */
	public interface WINAPI223 extends Callback {
		byte apply(lprec lp, Pointer row_string, int constr_type, double rh);
	};
	/** <i>native declaration : lp_lib.h:3133</i> */
	public interface WINAPI224 extends Callback {
		byte apply(lprec lp, Pointer row_string, int con_type, double rhs);
	};
	/** <i>native declaration : lp_lib.h:3134</i> */
	public interface WINAPI225 extends Callback {
		byte apply(lprec lp, Pointer row_string);
	};
	/** <i>native declaration : lp_lib.h:3135</i> */
	public interface WINAPI226 extends Callback {
		byte apply(lprec lp, Pointer rh_string);
	};
	/** <i>native declaration : lp_lib.h:3136</i> */
	public interface WINAPI227 extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3137</i> */
	public interface WINAPI228 extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3138</i> */
	public interface WINAPI229 extends Callback {
		byte apply(lprec lp, Pointer filename);
	};
	/** <i>native declaration : lp_lib.h:3139</i> */
	public interface WINAPI230 extends Callback {
		byte apply(lprec lp, Pointer output);
	};
	/** <i>native declaration : lp_lib.h:3140</i> */
	public interface WINAPI231 extends Callback {
		byte apply(lprec lp, Pointer filename);
	};
	/** <i>native declaration : lp_lib.h:3141</i> */
	public interface WINAPI232 extends Callback {
		byte apply(lprec lp, Pointer output);
	};
	/** <i>native declaration : lp_lib.h:3142</i> */
	public interface WINAPI233 extends Callback {
		byte apply(lprec lp, Pointer filename);
	};
	/** <i>native declaration : lp_lib.h:3143</i> */
	public interface WINAPI234 extends Callback {
		byte apply(lprec lp, Pointer output);
	};
	/** <i>native declaration : lp_lib.h:3144</i> */
	public interface WINAPI235 extends Callback {
		byte apply(lprec lp, Pointer filename, Pointer options, byte results);
	};
	/** <i>native declaration : lp_lib.h:3145</i> */
	public interface WINAPI236 extends Callback {
		byte apply(lprec lp, Pointer filename);
	};
	/** <i>native declaration : lp_lib.h:3146</i> */
	public interface WINAPI237 extends Callback {
		byte apply(lprec lp, Pointer filename, Pointer options);
	};
	/**
	 * -------------------------------------------------------------------------<br>
	 * <i>native declaration : lp_lib.h:3148</i>
	 */
	public interface WINAPI238 extends Callback {
		byte apply(lprec lp, int level);
	};
	/** <i>native declaration : lp_lib.h:3149</i> */
	public interface reportfunc extends Callback {
		void apply(lprec lp, int level, Pointer format, Object... varargs);
	};
	/** <i>native declaration : lp_lib.h:3151</i> */
	public interface WINAPI239 extends Callback {
		int apply(lprec lp, int varin, DoubleByReference pcol, IntByReference nzlist, IntByReference maxabs);
	};
	/** <i>native declaration : lp_lib.h:3152</i> */
	public interface WINAPI240 extends Callback {
		int apply(lprec lp, int j, IntByReference rn, DoubleByReference bj);
	};
	/** <i>native declaration : lp_lib.h:3153</i> */
	public interface WINAPI241 extends Callback {
		double apply(lprec lp, int varnr, double mult);
	};
	/** <i>native declaration : lp_lib.h:3154</i> */
	public interface WINAPI242 extends Callback {
		int apply(lprec lp, Pointer usedpos, IntByReference colorder, IntByReference size, byte symmetric);
	};
	/** <i>native declaration : lp_lib.h:3155</i> */
	public interface WINAPI243 extends Callback {
		byte apply(lprec lp, byte shiftbounds, byte char1);
	};
	/** <i>native declaration : lp_lib.h:3156</i> */
	public interface WINAPI244 extends Callback {
		void apply(IntByReference actionvar, int actionmask);
	};
	/** <i>native declaration : lp_lib.h:3157</i> */
	public interface WINAPI245 extends Callback {
		byte apply(int actionvar, int testmask);
	};
	/** <i>native declaration : lp_lib.h:3158</i> */
	public interface WINAPI246 extends Callback {
		void apply(IntByReference actionvar, int actionmask);
	};
	/** <i>native declaration : lp_lib.h:3161</i> */
	public interface BFP_lp extends Callback {
		void apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3162</i> */
	public interface BFP_lpint extends Callback {
		void apply(lprec lp, int newsize);
	};
	/** <i>native declaration : lp_lib.h:3163</i> */
	public interface BFPint_lp extends Callback {
		int apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3164</i> */
	public interface BFPint_lpint extends Callback {
		int apply(lprec lp, int kind);
	};
	/** <i>native declaration : lp_lib.h:3165</i> */
	public interface BFPreal_lp extends Callback {
		double apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3167</i> */
	public interface BFP_lpbool extends Callback {
		void apply(lprec lp, byte maximum);
	};
	/** <i>native declaration : lp_lib.h:3168</i> */
	public interface BFPint_lpbool extends Callback {
		int apply(lprec lp, byte maximum);
	};
	/** <i>native declaration : lp_lib.h:3169</i> */
	public interface BFPint_lpintintboolbool extends Callback {
		int apply(lprec lp, int uservars, int Bsize, Pointer usedpos, byte char1);
	};
	/** <i>native declaration : lp_lib.h:3170</i> */
	public interface BFP_lprealint extends Callback {
		void apply(lprec lp, DoubleByReference pcol, IntByReference nzidx);
	};
	/** <i>native declaration : lp_lib.h:3171</i> */
	public interface BFP_lprealintrealint extends Callback {
		void apply(lprec lp, DoubleByReference prow, IntByReference pnzidx, DoubleByReference drow, IntByReference dnzidx);
	};
	/** <i>native declaration : lp_lib.h:3172</i> */
	public interface BFPbool_lp extends Callback {
		byte apply(lprec lp);
	};
	/** <i>native declaration : lp_lib.h:3173</i> */
	public interface BFPbool_lpbool extends Callback {
		byte apply(lprec lp, byte changesign);
	};
	/** <i>native declaration : lp_lib.h:3174</i> */
	public interface BFPbool_lpint extends Callback {
		byte apply(lprec lp, int size);
	};
	/** <i>native declaration : lp_lib.h:3175</i> */
	public interface BFPbool_lpintintchar extends Callback {
		byte apply(lprec lp, int size, int deltasize, Pointer options);
	};
	/** <i>native declaration : lp_lib.h:3176</i> */
	public interface BFPbool_lpintintint extends Callback {
		byte apply(lprec lp, int size, int deltasize, int sizeofvar);
	};
	/** <i>native declaration : lp_lib.h:3177</i> */
	public interface BFPlreal_lpintintreal extends Callback {
		double apply(lprec lp, int row_nr, int col_nr, DoubleByReference pcol);
	};
	/** <i>native declaration : lp_lib.h:3178</i> */
	public interface BFPreal_lplrealreal extends Callback {
		double apply(lprec lp, double theta, DoubleByReference pcol);
	};
	/** <i>native declaration : lp_lib.h:3179</i> */
	public interface getcolumnex_func extends Callback {
		int apply(lprec lp, int colnr, DoubleByReference nzvalues, IntByReference nzrows, IntByReference mapin);
	};
	/** <i>native declaration : lp_lib.h:3180</i> */
	public interface BFPint_lpintrealcbintint extends Callback {
		int apply(lprec lp, int items, LpSolveLibLibrary.getcolumnex_func cb, IntByReference maprow, IntByReference mapcol);
	};
	/** <i>native declaration : lp_lib.h:3183</i> */
	public interface XLIbool_lpintintint extends Callback {
		byte apply(lprec lp, int size, int deltasize, int sizevar);
	};
	/** <i>native declaration : lp_lib.h:3184</i> */
	public interface XLIbool_lpcharcharcharint extends Callback {
		byte apply(lprec lp, Pointer modelname, Pointer dataname, Pointer options, int verbose);
	};
	/** <i>native declaration : lp_lib.h:3185</i> */
	public interface XLIbool_lpcharcharbool extends Callback {
		byte apply(lprec lp, Pointer filename, Pointer options, byte results);
	};
	/** <i>native declaration : lp_lib.h:4237</i> */
	public interface WINAPI247 extends Callback {
		int apply(Pointer userhandle, Pointer buf, int max_size);
	};
	/** <i>native declaration : lp_lib.h:4238</i> */
	public interface WINAPI248 extends Callback {
		int apply(Pointer userhandle, Pointer buf);
	};
	/**
	 * Original signature : <code>WINAPI lp_solve_version(int*, int*, int*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3726</i><br>
	 * @deprecated use the safer methods {@link #lp_solve_version(java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #lp_solve_version(com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI lp_solve_version(IntByReference majorversion, IntByReference minorversion, IntByReference release, IntByReference build);
	/**
	 * Original signature : <code>WINAPI lp_solve_version(int*, int*, int*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3726</i>
	 */
	public static native LpSolveLibLibrary.WINAPI lp_solve_version(IntBuffer majorversion, IntBuffer minorversion, IntBuffer release, IntBuffer build);
	/**
	 * Original signature : <code>WINAPI make_lp(int, int)</code><br>
	 * <i>native declaration : lp_lib.h:3728</i>
	 */
	public static native LpSolveLibLibrary.WINAPI make_lp(int rows, int columns);
	/**
	 * Original signature : <code>WINAPI resize_lp(lprec*, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:3730</i>
	 */
	public static native LpSolveLibLibrary.WINAPI resize_lp(lprec lp, int rows, int columns);
	/**
	 * Original signature : <code>WINAPI get_status(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3732</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_status(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_statustext(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3734</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_statustext(lprec lp, int statuscode);
	/**
	 * Original signature : <code>WINAPI is_obj_in_basis(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3736</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_obj_in_basis(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_obj_in_basis(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3738</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_obj_in_basis(lprec lp, byte obj_in_basis);
	/**
	 * Original signature : <code>WINAPI copy_lp(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3740</i>
	 */
	public static native LpSolveLibLibrary.WINAPI copy_lp(lprec lp);
	/**
	 * Original signature : <code>WINAPI dualize_lp(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3742</i>
	 */
	public static native LpSolveLibLibrary.WINAPI dualize_lp(lprec lp);
	/**
	 * Original signature : <code>char memopt_lp(lprec*, int, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:3744</i>
	 */
	public static native byte memopt_lp(lprec lp, int rowextra, int colextra, int nzextra);
	/**
	 * Original signature : <code>WINAPI delete_lp(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3746</i>
	 */
	public static native LpSolveLibLibrary.WINAPI delete_lp(lprec lp);
	/**
	 * Original signature : <code>WINAPI free_lp(lprec**)</code><br>
	 * <i>native declaration : lp_lib.h:3748</i><br>
	 * @deprecated use the safer method {@link #free_lp(lpsolvelib.lprec.ByReference[])} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI free_lp(PointerByReference plp);
	/**
	 * Original signature : <code>WINAPI free_lp(lprec**)</code><br>
	 * <i>native declaration : lp_lib.h:3748</i>
	 */
	public static native LpSolveLibLibrary.WINAPI free_lp(lprec.ByReference plp[]);
	/**
	 * Original signature : <code>WINAPI set_lp_name(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3750</i><br>
	 * @deprecated use the safer methods {@link #set_lp_name(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #set_lp_name(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_lp_name(lprec lp, Pointer lpname);
	/**
	 * Original signature : <code>WINAPI set_lp_name(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3750</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_lp_name(lprec lp, ByteBuffer lpname);
	/**
	 * Original signature : <code>WINAPI get_lp_name(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3752</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_lp_name(lprec lp);
	/**
	 * Original signature : <code>WINAPI has_BFP(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3754</i>
	 */
	public static native LpSolveLibLibrary.WINAPI has_BFP(lprec lp);
	/**
	 * Original signature : <code>WINAPI is_nativeBFP(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3756</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_nativeBFP(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_BFP(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3758</i><br>
	 * @deprecated use the safer methods {@link #set_BFP(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #set_BFP(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_BFP(lprec lp, Pointer filename);
	/**
	 * Original signature : <code>WINAPI set_BFP(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3758</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_BFP(lprec lp, ByteBuffer filename);
	/**
	 * Original signature : <code>WINAPI read_XLI(char*, char*, char*, char*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3760</i><br>
	 * @deprecated use the safer methods {@link #read_XLI(java.nio.ByteBuffer, java.nio.ByteBuffer, java.nio.ByteBuffer, java.nio.ByteBuffer, int)} and {@link #read_XLI(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI read_XLI(Pointer xliname, Pointer modelname, Pointer dataname, Pointer options, int verbose);
	/**
	 * Original signature : <code>WINAPI read_XLI(char*, char*, char*, char*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3760</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_XLI(ByteBuffer xliname, ByteBuffer modelname, ByteBuffer dataname, ByteBuffer options, int verbose);
	/**
	 * Original signature : <code>WINAPI write_XLI(lprec*, char*, char*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3762</i><br>
	 * @deprecated use the safer methods {@link #write_XLI(lpsolvelib.lprec, java.nio.ByteBuffer, java.nio.ByteBuffer, byte)} and {@link #write_XLI(lpsolvelib.lprec, com.sun.jna.Pointer, com.sun.jna.Pointer, byte)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI write_XLI(lprec lp, Pointer filename, Pointer options, byte results);
	/**
	 * Original signature : <code>WINAPI write_XLI(lprec*, char*, char*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3762</i>
	 */
	public static native LpSolveLibLibrary.WINAPI write_XLI(lprec lp, ByteBuffer filename, ByteBuffer options, byte results);
	/**
	 * Original signature : <code>WINAPI has_XLI(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3764</i>
	 */
	public static native LpSolveLibLibrary.WINAPI has_XLI(lprec lp);
	/**
	 * Original signature : <code>WINAPI is_nativeXLI(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3766</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_nativeXLI(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_XLI(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3768</i><br>
	 * @deprecated use the safer methods {@link #set_XLI(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #set_XLI(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_XLI(lprec lp, Pointer filename);
	/**
	 * Original signature : <code>WINAPI set_XLI(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3768</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_XLI(lprec lp, ByteBuffer filename);
	/**
	 * Original signature : <code>WINAPI set_obj(lprec*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3770</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_obj(lprec lp, int colnr, double value);
	/**
	 * Original signature : <code>WINAPI set_obj_fn(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3772</i><br>
	 * @deprecated use the safer methods {@link #set_obj_fn(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #set_obj_fn(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_obj_fn(lprec lp, DoubleByReference row);
	/**
	 * Original signature : <code>WINAPI set_obj_fn(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3772</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_obj_fn(lprec lp, DoubleBuffer row);
	/**
	 * Original signature : <code>WINAPI set_obj_fnex(lprec*, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3774</i><br>
	 * @deprecated use the safer methods {@link #set_obj_fnex(lpsolvelib.lprec, int, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #set_obj_fnex(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_obj_fnex(lprec lp, int count, DoubleByReference row, IntByReference colno);
	/**
	 * Original signature : <code>WINAPI set_obj_fnex(lprec*, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3774</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_obj_fnex(lprec lp, int count, DoubleBuffer row, IntBuffer colno);
	/**
	 * Original signature : <code>WINAPI str_set_obj_fn(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3776</i><br>
	 * @deprecated use the safer methods {@link #str_set_obj_fn(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #str_set_obj_fn(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI str_set_obj_fn(lprec lp, Pointer row_string);
	/**
	 * Original signature : <code>WINAPI str_set_obj_fn(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3776</i>
	 */
	public static native LpSolveLibLibrary.WINAPI str_set_obj_fn(lprec lp, ByteBuffer row_string);
	/**
	 * Original signature : <code>WINAPI set_sense(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3778</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_sense(lprec lp, byte maximize);
	/**
	 * Original signature : <code>WINAPI set_maxim(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3780</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_maxim(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_minim(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3782</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_minim(lprec lp);
	/**
	 * Original signature : <code>WINAPI is_maxim(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3784</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_maxim(lprec lp);
	/**
	 * Original signature : <code>WINAPI add_constraint(lprec*, double*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3786</i><br>
	 * @deprecated use the safer methods {@link #add_constraint(lpsolvelib.lprec, java.nio.DoubleBuffer, int, double)} and {@link #add_constraint(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, int, double)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI add_constraint(lprec lp, DoubleByReference row, int constr_type, double rh);
	/**
	 * Original signature : <code>WINAPI add_constraint(lprec*, double*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3786</i>
	 */
	public static native LpSolveLibLibrary.WINAPI add_constraint(lprec lp, DoubleBuffer row, int constr_type, double rh);
	/**
	 * Original signature : <code>WINAPI add_constraintex(lprec*, int, double*, int*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3788</i><br>
	 * @deprecated use the safer methods {@link #add_constraintex(lpsolvelib.lprec, int, java.nio.DoubleBuffer, java.nio.IntBuffer, int, double)} and {@link #add_constraintex(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, int, double)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI add_constraintex(lprec lp, int count, DoubleByReference row, IntByReference colno, int constr_type, double rh);
	/**
	 * Original signature : <code>WINAPI add_constraintex(lprec*, int, double*, int*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3788</i>
	 */
	public static native LpSolveLibLibrary.WINAPI add_constraintex(lprec lp, int count, DoubleBuffer row, IntBuffer colno, int constr_type, double rh);
	/**
	 * Original signature : <code>WINAPI set_add_rowmode(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3790</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_add_rowmode(lprec lp, byte turnon);
	/**
	 * Original signature : <code>WINAPI is_add_rowmode(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3792</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_add_rowmode(lprec lp);
	/**
	 * Original signature : <code>WINAPI str_add_constraint(lprec*, char*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3794</i><br>
	 * @deprecated use the safer methods {@link #str_add_constraint(lpsolvelib.lprec, java.nio.ByteBuffer, int, double)} and {@link #str_add_constraint(lpsolvelib.lprec, com.sun.jna.Pointer, int, double)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI str_add_constraint(lprec lp, Pointer row_string, int constr_type, double rh);
	/**
	 * Original signature : <code>WINAPI str_add_constraint(lprec*, char*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3794</i>
	 */
	public static native LpSolveLibLibrary.WINAPI str_add_constraint(lprec lp, ByteBuffer row_string, int constr_type, double rh);
	/**
	 * Original signature : <code>WINAPI set_row(lprec*, int, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3796</i><br>
	 * @deprecated use the safer methods {@link #set_row(lpsolvelib.lprec, int, java.nio.DoubleBuffer)} and {@link #set_row(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_row(lprec lp, int rownr, DoubleByReference row);
	/**
	 * Original signature : <code>WINAPI set_row(lprec*, int, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3796</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_row(lprec lp, int rownr, DoubleBuffer row);
	/**
	 * Original signature : <code>WINAPI set_rowex(lprec*, int, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3798</i><br>
	 * @deprecated use the safer methods {@link #set_rowex(lpsolvelib.lprec, int, int, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #set_rowex(lpsolvelib.lprec, int, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_rowex(lprec lp, int rownr, int count, DoubleByReference row, IntByReference colno);
	/**
	 * Original signature : <code>WINAPI set_rowex(lprec*, int, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3798</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_rowex(lprec lp, int rownr, int count, DoubleBuffer row, IntBuffer colno);
	/**
	 * Original signature : <code>WINAPI get_row(lprec*, int, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3800</i><br>
	 * @deprecated use the safer methods {@link #get_row(lpsolvelib.lprec, int, java.nio.DoubleBuffer)} and {@link #get_row(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_row(lprec lp, int rownr, DoubleByReference row);
	/**
	 * Original signature : <code>WINAPI get_row(lprec*, int, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3800</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_row(lprec lp, int rownr, DoubleBuffer row);
	/**
	 * Original signature : <code>WINAPI get_rowex(lprec*, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3802</i><br>
	 * @deprecated use the safer methods {@link #get_rowex(lpsolvelib.lprec, int, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #get_rowex(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_rowex(lprec lp, int rownr, DoubleByReference row, IntByReference colno);
	/**
	 * Original signature : <code>WINAPI get_rowex(lprec*, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3802</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_rowex(lprec lp, int rownr, DoubleBuffer row, IntBuffer colno);
	/**
	 * Original signature : <code>WINAPI del_constraint(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3804</i>
	 */
	public static native LpSolveLibLibrary.WINAPI del_constraint(lprec lp, int rownr);
	/**
	 * Original signature : <code>char del_constraintex(lprec*, LLrec*)</code><br>
	 * <i>native declaration : lp_lib.h:3806</i>
	 */
	public static native byte del_constraintex(lprec lp, LLrec rowmap);
	/**
	 * Original signature : <code>WINAPI add_lag_con(lprec*, double*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3808</i><br>
	 * @deprecated use the safer methods {@link #add_lag_con(lpsolvelib.lprec, java.nio.DoubleBuffer, int, double)} and {@link #add_lag_con(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, int, double)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI add_lag_con(lprec lp, DoubleByReference row, int con_type, double rhs);
	/**
	 * Original signature : <code>WINAPI add_lag_con(lprec*, double*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3808</i>
	 */
	public static native LpSolveLibLibrary.WINAPI add_lag_con(lprec lp, DoubleBuffer row, int con_type, double rhs);
	/**
	 * Original signature : <code>WINAPI str_add_lag_con(lprec*, char*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3810</i><br>
	 * @deprecated use the safer methods {@link #str_add_lag_con(lpsolvelib.lprec, java.nio.ByteBuffer, int, double)} and {@link #str_add_lag_con(lpsolvelib.lprec, com.sun.jna.Pointer, int, double)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI str_add_lag_con(lprec lp, Pointer row_string, int con_type, double rhs);
	/**
	 * Original signature : <code>WINAPI str_add_lag_con(lprec*, char*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3810</i>
	 */
	public static native LpSolveLibLibrary.WINAPI str_add_lag_con(lprec lp, ByteBuffer row_string, int con_type, double rhs);
	/**
	 * Original signature : <code>WINAPI set_lag_trace(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3812</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_lag_trace(lprec lp, byte lag_trace);
	/**
	 * Original signature : <code>WINAPI is_lag_trace(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3814</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_lag_trace(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_constr_type(lprec*, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:3816</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_constr_type(lprec lp, int rownr, int con_type);
	/**
	 * Original signature : <code>WINAPI get_constr_type(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3818</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_constr_type(lprec lp, int rownr);
	/**
	 * Original signature : <code>WINAPI get_constr_value(lprec*, int, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3820</i><br>
	 * @deprecated use the safer methods {@link #get_constr_value(lpsolvelib.lprec, int, int, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #get_constr_value(lpsolvelib.lprec, int, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_constr_value(lprec lp, int rownr, int count, DoubleByReference primsolution, IntByReference nzindex);
	/**
	 * Original signature : <code>WINAPI get_constr_value(lprec*, int, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3820</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_constr_value(lprec lp, int rownr, int count, DoubleBuffer primsolution, IntBuffer nzindex);
	/**
	 * Original signature : <code>WINAPI is_constr_type(lprec*, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:3822</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_constr_type(lprec lp, int rownr, int mask);
	/**
	 * Original signature : <code>char* get_str_constr_type(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3824</i>
	 */
	public static native Pointer get_str_constr_type(lprec lp, int con_type);
	/**
	 * Original signature : <code>int get_constr_class(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3826</i>
	 */
	public static native int get_constr_class(lprec lp, int rownr);
	/**
	 * Original signature : <code>char* get_str_constr_class(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3828</i>
	 */
	public static native Pointer get_str_constr_class(lprec lp, int con_class);
	/**
	 * Original signature : <code>WINAPI set_rh(lprec*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3830</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_rh(lprec lp, int rownr, double value);
	/**
	 * Original signature : <code>WINAPI get_rh(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3832</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_rh(lprec lp, int rownr);
	/**
	 * Original signature : <code>WINAPI set_rh_range(lprec*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3834</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_rh_range(lprec lp, int rownr, double deltavalue);
	/**
	 * Original signature : <code>WINAPI get_rh_range(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3836</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_rh_range(lprec lp, int rownr);
	/**
	 * Original signature : <code>WINAPI set_rh_vec(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3838</i><br>
	 * @deprecated use the safer methods {@link #set_rh_vec(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #set_rh_vec(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_rh_vec(lprec lp, DoubleByReference rh);
	/**
	 * Original signature : <code>WINAPI set_rh_vec(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3838</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_rh_vec(lprec lp, DoubleBuffer rh);
	/**
	 * Original signature : <code>WINAPI str_set_rh_vec(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3840</i><br>
	 * @deprecated use the safer methods {@link #str_set_rh_vec(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #str_set_rh_vec(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI str_set_rh_vec(lprec lp, Pointer rh_string);
	/**
	 * Original signature : <code>WINAPI str_set_rh_vec(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3840</i>
	 */
	public static native LpSolveLibLibrary.WINAPI str_set_rh_vec(lprec lp, ByteBuffer rh_string);
	/**
	 * Original signature : <code>WINAPI add_column(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3842</i><br>
	 * @deprecated use the safer methods {@link #add_column(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #add_column(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI add_column(lprec lp, DoubleByReference column);
	/**
	 * Original signature : <code>WINAPI add_column(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3842</i>
	 */
	public static native LpSolveLibLibrary.WINAPI add_column(lprec lp, DoubleBuffer column);
	/**
	 * Original signature : <code>WINAPI add_columnex(lprec*, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3844</i><br>
	 * @deprecated use the safer methods {@link #add_columnex(lpsolvelib.lprec, int, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #add_columnex(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI add_columnex(lprec lp, int count, DoubleByReference column, IntByReference rowno);
	/**
	 * Original signature : <code>WINAPI add_columnex(lprec*, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3844</i>
	 */
	public static native LpSolveLibLibrary.WINAPI add_columnex(lprec lp, int count, DoubleBuffer column, IntBuffer rowno);
	/**
	 * Original signature : <code>WINAPI str_add_column(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3846</i><br>
	 * @deprecated use the safer methods {@link #str_add_column(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #str_add_column(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI str_add_column(lprec lp, Pointer col_string);
	/**
	 * Original signature : <code>WINAPI str_add_column(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3846</i>
	 */
	public static native LpSolveLibLibrary.WINAPI str_add_column(lprec lp, ByteBuffer col_string);
	/**
	 * Original signature : <code>WINAPI set_column(lprec*, int, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3848</i><br>
	 * @deprecated use the safer methods {@link #set_column(lpsolvelib.lprec, int, java.nio.DoubleBuffer)} and {@link #set_column(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_column(lprec lp, int colnr, DoubleByReference column);
	/**
	 * Original signature : <code>WINAPI set_column(lprec*, int, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3848</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_column(lprec lp, int colnr, DoubleBuffer column);
	/**
	 * Original signature : <code>WINAPI set_columnex(lprec*, int, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3850</i><br>
	 * @deprecated use the safer methods {@link #set_columnex(lpsolvelib.lprec, int, int, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #set_columnex(lpsolvelib.lprec, int, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_columnex(lprec lp, int colnr, int count, DoubleByReference column, IntByReference rowno);
	/**
	 * Original signature : <code>WINAPI set_columnex(lprec*, int, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3850</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_columnex(lprec lp, int colnr, int count, DoubleBuffer column, IntBuffer rowno);
	/**
	 * Original signature : <code>WINAPI column_in_lp(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3852</i><br>
	 * @deprecated use the safer methods {@link #column_in_lp(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #column_in_lp(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI column_in_lp(lprec lp, DoubleByReference column);
	/**
	 * Original signature : <code>WINAPI column_in_lp(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3852</i>
	 */
	public static native LpSolveLibLibrary.WINAPI column_in_lp(lprec lp, DoubleBuffer column);
	/**
	 * Original signature : <code>WINAPI get_columnex(lprec*, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3854</i><br>
	 * @deprecated use the safer methods {@link #get_columnex(lpsolvelib.lprec, int, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #get_columnex(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_columnex(lprec lp, int colnr, DoubleByReference column, IntByReference nzrow);
	/**
	 * Original signature : <code>WINAPI get_columnex(lprec*, int, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3854</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_columnex(lprec lp, int colnr, DoubleBuffer column, IntBuffer nzrow);
	/**
	 * Original signature : <code>WINAPI get_column(lprec*, int, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3856</i><br>
	 * @deprecated use the safer methods {@link #get_column(lpsolvelib.lprec, int, java.nio.DoubleBuffer)} and {@link #get_column(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_column(lprec lp, int colnr, DoubleByReference column);
	/**
	 * Original signature : <code>WINAPI get_column(lprec*, int, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3856</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_column(lprec lp, int colnr, DoubleBuffer column);
	/**
	 * Original signature : <code>WINAPI del_column(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3858</i>
	 */
	public static native LpSolveLibLibrary.WINAPI del_column(lprec lp, int colnr);
	/**
	 * Original signature : <code>char del_columnex(lprec*, LLrec*)</code><br>
	 * <i>native declaration : lp_lib.h:3860</i>
	 */
	public static native byte del_columnex(lprec lp, LLrec colmap);
	/**
	 * Original signature : <code>WINAPI set_mat(lprec*, int, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3862</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_mat(lprec lp, int rownr, int colnr, double value);
	/**
	 * Original signature : <code>WINAPI get_mat(lprec*, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:3864</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_mat(lprec lp, int rownr, int colnr);
	/**
	 * Original signature : <code>WINAPI get_mat_byindex(lprec*, int, unsigned char, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3866</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_mat_byindex(lprec lp, int matindex, byte isrow, byte adjustsign);
	/**
	 * Original signature : <code>WINAPI get_nonzeros(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3868</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_nonzeros(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_bounds_tighter(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3870</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_bounds_tighter(lprec lp, byte tighten);
	/**
	 * Original signature : <code>char get_bounds(lprec*, int, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3872</i><br>
	 * @deprecated use the safer methods {@link #get_bounds(lpsolvelib.lprec, int, java.nio.DoubleBuffer, java.nio.DoubleBuffer)} and {@link #get_bounds(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native byte get_bounds(lprec lp, int column, DoubleByReference lower, DoubleByReference upper);
	/**
	 * Original signature : <code>char get_bounds(lprec*, int, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3872</i>
	 */
	public static native byte get_bounds(lprec lp, int column, DoubleBuffer lower, DoubleBuffer upper);
	/**
	 * Original signature : <code>WINAPI get_bounds_tighter(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3874</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_bounds_tighter(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_upbo(lprec*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3876</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_upbo(lprec lp, int colnr, double value);
	/**
	 * Original signature : <code>WINAPI get_upbo(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3878</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_upbo(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI set_lowbo(lprec*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:3880</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_lowbo(lprec lp, int colnr, double value);
	/**
	 * Original signature : <code>WINAPI get_lowbo(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3882</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_lowbo(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI set_bounds(lprec*, int, double, double)</code><br>
	 * <i>native declaration : lp_lib.h:3884</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_bounds(lprec lp, int colnr, double lower, double upper);
	/**
	 * Original signature : <code>WINAPI set_unbounded(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3886</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_unbounded(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI is_unbounded(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3888</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_unbounded(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI set_int(lprec*, int, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3890</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_int(lprec lp, int colnr, byte must_be_int);
	/**
	 * Original signature : <code>WINAPI is_int(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3892</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_int(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI set_binary(lprec*, int, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3894</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_binary(lprec lp, int colnr, byte must_be_bin);
	/**
	 * Original signature : <code>WINAPI is_binary(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3896</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_binary(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI set_semicont(lprec*, int, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3898</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_semicont(lprec lp, int colnr, byte must_be_sc);
	/**
	 * Original signature : <code>WINAPI is_semicont(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3900</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_semicont(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI is_negative(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3902</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_negative(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI set_var_weights(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3904</i><br>
	 * @deprecated use the safer methods {@link #set_var_weights(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #set_var_weights(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_var_weights(lprec lp, DoubleByReference weights);
	/**
	 * Original signature : <code>WINAPI set_var_weights(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3904</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_var_weights(lprec lp, DoubleBuffer weights);
	/**
	 * Original signature : <code>WINAPI get_var_priority(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3906</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_var_priority(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI set_pseudocosts(lprec*, double*, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3908</i><br>
	 * @deprecated use the safer methods {@link #set_pseudocosts(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #set_pseudocosts(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_pseudocosts(lprec lp, DoubleByReference clower, DoubleByReference cupper, IntByReference updatelimit);
	/**
	 * Original signature : <code>WINAPI set_pseudocosts(lprec*, double*, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3908</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_pseudocosts(lprec lp, DoubleBuffer clower, DoubleBuffer cupper, IntBuffer updatelimit);
	/**
	 * Original signature : <code>WINAPI get_pseudocosts(lprec*, double*, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3910</i><br>
	 * @deprecated use the safer methods {@link #get_pseudocosts(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #get_pseudocosts(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_pseudocosts(lprec lp, DoubleByReference clower, DoubleByReference cupper, IntByReference updatelimit);
	/**
	 * Original signature : <code>WINAPI get_pseudocosts(lprec*, double*, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3910</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_pseudocosts(lprec lp, DoubleBuffer clower, DoubleBuffer cupper, IntBuffer updatelimit);
	/**
	 * Original signature : <code>WINAPI add_SOS(lprec*, char*, int, int, int, int*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3912</i><br>
	 * @deprecated use the safer methods {@link #add_SOS(lpsolvelib.lprec, java.nio.ByteBuffer, int, int, int, java.nio.IntBuffer, java.nio.DoubleBuffer)} and {@link #add_SOS(lpsolvelib.lprec, com.sun.jna.Pointer, int, int, int, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI add_SOS(lprec lp, Pointer name, int sostype, int priority, int count, IntByReference sosvars, DoubleByReference weights);
	/**
	 * Original signature : <code>WINAPI add_SOS(lprec*, char*, int, int, int, int*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3912</i>
	 */
	public static native LpSolveLibLibrary.WINAPI add_SOS(lprec lp, ByteBuffer name, int sostype, int priority, int count, IntBuffer sosvars, DoubleBuffer weights);
	/**
	 * Original signature : <code>WINAPI is_SOS_var(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3914</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_SOS_var(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI set_row_name(lprec*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3916</i><br>
	 * @deprecated use the safer methods {@link #set_row_name(lpsolvelib.lprec, int, java.nio.ByteBuffer)} and {@link #set_row_name(lpsolvelib.lprec, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_row_name(lprec lp, int rownr, Pointer new_name);
	/**
	 * Original signature : <code>WINAPI set_row_name(lprec*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3916</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_row_name(lprec lp, int rownr, ByteBuffer new_name);
	/**
	 * Original signature : <code>WINAPI get_row_name(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3918</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_row_name(lprec lp, int rownr);
	/**
	 * Original signature : <code>WINAPI get_origrow_name(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3920</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_origrow_name(lprec lp, int rownr);
	/**
	 * Original signature : <code>WINAPI set_col_name(lprec*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3922</i><br>
	 * @deprecated use the safer methods {@link #set_col_name(lpsolvelib.lprec, int, java.nio.ByteBuffer)} and {@link #set_col_name(lpsolvelib.lprec, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_col_name(lprec lp, int colnr, Pointer new_name);
	/**
	 * Original signature : <code>WINAPI set_col_name(lprec*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3922</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_col_name(lprec lp, int colnr, ByteBuffer new_name);
	/**
	 * Original signature : <code>WINAPI get_col_name(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3924</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_col_name(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI get_origcol_name(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3926</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_origcol_name(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI unscale(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3928</i>
	 */
	public static native LpSolveLibLibrary.WINAPI unscale(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_preferdual(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3930</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_preferdual(lprec lp, byte dodual);
	/**
	 * Original signature : <code>WINAPI set_simplextype(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3932</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_simplextype(lprec lp, int simplextype);
	/**
	 * Original signature : <code>WINAPI get_simplextype(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3934</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_simplextype(lprec lp);
	/**
	 * Original signature : <code>WINAPI default_basis(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3936</i>
	 */
	public static native LpSolveLibLibrary.WINAPI default_basis(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_basiscrash(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3938</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_basiscrash(lprec lp, int mode);
	/**
	 * Original signature : <code>WINAPI get_basiscrash(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3940</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_basiscrash(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_basisvar(lprec*, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:3942</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_basisvar(lprec lp, int basisPos, int enteringCol);
	/**
	 * Original signature : <code>WINAPI set_basis(lprec*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3944</i><br>
	 * @deprecated use the safer methods {@link #set_basis(lpsolvelib.lprec, java.nio.IntBuffer, byte)} and {@link #set_basis(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, byte)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_basis(lprec lp, IntByReference bascolumn, byte nonbasic);
	/**
	 * Original signature : <code>WINAPI set_basis(lprec*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3944</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_basis(lprec lp, IntBuffer bascolumn, byte nonbasic);
	/**
	 * Original signature : <code>WINAPI get_basis(lprec*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3946</i><br>
	 * @deprecated use the safer methods {@link #get_basis(lpsolvelib.lprec, java.nio.IntBuffer, byte)} and {@link #get_basis(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, byte)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_basis(lprec lp, IntByReference bascolumn, byte nonbasic);
	/**
	 * Original signature : <code>WINAPI get_basis(lprec*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:3946</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_basis(lprec lp, IntBuffer bascolumn, byte nonbasic);
	/**
	 * Original signature : <code>WINAPI reset_basis(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3948</i>
	 */
	public static native LpSolveLibLibrary.WINAPI reset_basis(lprec lp);
	/**
	 * Original signature : <code>WINAPI guess_basis(lprec*, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3950</i><br>
	 * @deprecated use the safer methods {@link #guess_basis(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #guess_basis(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI guess_basis(lprec lp, DoubleByReference guessvector, IntByReference basisvector);
	/**
	 * Original signature : <code>WINAPI guess_basis(lprec*, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:3950</i>
	 */
	public static native LpSolveLibLibrary.WINAPI guess_basis(lprec lp, DoubleBuffer guessvector, IntBuffer basisvector);
	/**
	 * Original signature : <code>WINAPI is_feasible(lprec*, double*, double)</code><br>
	 * <i>native declaration : lp_lib.h:3952</i><br>
	 * @deprecated use the safer methods {@link #is_feasible(lpsolvelib.lprec, java.nio.DoubleBuffer, double)} and {@link #is_feasible(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, double)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI is_feasible(lprec lp, DoubleByReference values, double threshold);
	/**
	 * Original signature : <code>WINAPI is_feasible(lprec*, double*, double)</code><br>
	 * <i>native declaration : lp_lib.h:3952</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_feasible(lprec lp, DoubleBuffer values, double threshold);
	/**
	 * Original signature : <code>WINAPI solve(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3954</i>
	 */
	public static native LpSolveLibLibrary.WINAPI solve(lprec lp);
	/**
	 * Original signature : <code>WINAPI time_elapsed(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:3956</i>
	 */
	public static native LpSolveLibLibrary.WINAPI time_elapsed(lprec lp);
	/**
	 * Original signature : <code>WINAPI put_bb_nodefunc(lprec*, lphandleint_intfunc, void*)</code><br>
	 * <i>native declaration : lp_lib.h:3958</i>
	 */
	public static native LpSolveLibLibrary.WINAPI put_bb_nodefunc(lprec lp, LpSolveLibLibrary.lphandleint_intfunc newnode, Pointer bbnodehandle);
	/**
	 * Original signature : <code>WINAPI put_bb_branchfunc(lprec*, lphandleint_intfunc, void*)</code><br>
	 * <i>native declaration : lp_lib.h:3960</i>
	 */
	public static native LpSolveLibLibrary.WINAPI put_bb_branchfunc(lprec lp, LpSolveLibLibrary.lphandleint_intfunc newbranch, Pointer bbbranchhandle);
	/**
	 * Original signature : <code>WINAPI put_abortfunc(lprec*, lphandle_intfunc, void*)</code><br>
	 * <i>native declaration : lp_lib.h:3962</i>
	 */
	public static native LpSolveLibLibrary.WINAPI put_abortfunc(lprec lp, LpSolveLibLibrary.lphandle_intfunc newctrlc, Pointer ctrlchandle);
	/**
	 * Original signature : <code>WINAPI put_logfunc(lprec*, lphandlestr_func, void*)</code><br>
	 * <i>native declaration : lp_lib.h:3964</i>
	 */
	public static native LpSolveLibLibrary.WINAPI put_logfunc(lprec lp, LpSolveLibLibrary.lphandlestr_func newlog, Pointer loghandle);
	/**
	 * Original signature : <code>WINAPI put_msgfunc(lprec*, lphandleint_func, void*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3966</i>
	 */
	public static native LpSolveLibLibrary.WINAPI put_msgfunc(lprec lp, LpSolveLibLibrary.lphandleint_func newmsg, Pointer msghandle, int mask);
	/**
	 * Original signature : <code>WINAPI get_primal_solution(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3968</i><br>
	 * @deprecated use the safer methods {@link #get_primal_solution(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #get_primal_solution(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_primal_solution(lprec lp, DoubleByReference pv);
	/**
	 * Original signature : <code>WINAPI get_primal_solution(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3968</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_primal_solution(lprec lp, DoubleBuffer pv);
	/**
	 * Original signature : <code>WINAPI get_ptr_primal_solution(lprec*, double**)</code><br>
	 * <i>native declaration : lp_lib.h:3970</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_ptr_primal_solution(lprec lp, PointerByReference pv);
	/**
	 * Original signature : <code>WINAPI get_dual_solution(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3972</i><br>
	 * @deprecated use the safer methods {@link #get_dual_solution(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #get_dual_solution(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_dual_solution(lprec lp, DoubleByReference rc);
	/**
	 * Original signature : <code>WINAPI get_dual_solution(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3972</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_dual_solution(lprec lp, DoubleBuffer rc);
	/**
	 * Original signature : <code>WINAPI get_ptr_dual_solution(lprec*, double**)</code><br>
	 * <i>native declaration : lp_lib.h:3974</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_ptr_dual_solution(lprec lp, PointerByReference rc);
	/**
	 * Original signature : <code>WINAPI get_lambda(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3976</i><br>
	 * @deprecated use the safer methods {@link #get_lambda(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #get_lambda(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_lambda(lprec lp, DoubleByReference lambda);
	/**
	 * Original signature : <code>WINAPI get_lambda(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:3976</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_lambda(lprec lp, DoubleBuffer lambda);
	/**
	 * Original signature : <code>WINAPI get_ptr_lambda(lprec*, double**)</code><br>
	 * <i>native declaration : lp_lib.h:3978</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_ptr_lambda(lprec lp, PointerByReference lambda);
	/**
	 * Original signature : <code>WINAPI read_MPS(char*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3980</i><br>
	 * @deprecated use the safer methods {@link #read_MPS(java.nio.ByteBuffer, int)} and {@link #read_MPS(com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI read_MPS(Pointer filename, int options);
	/**
	 * Original signature : <code>WINAPI read_MPS(char*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3980</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_MPS(ByteBuffer filename, int options);
	/**
	 * Original signature : <code>WINAPI read_mps(FILE*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3982</i><br>
	 * @deprecated use the safer method {@link #read_mps(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI read_mps(Pointer filename, int options);
	/**
	 * Original signature : <code>WINAPI read_mps(FILE*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3982</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_mps(PointerByReference filename, int options);
	/**
	 * Original signature : <code>WINAPI read_freeMPS(char*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3984</i><br>
	 * @deprecated use the safer methods {@link #read_freeMPS(java.nio.ByteBuffer, int)} and {@link #read_freeMPS(com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI read_freeMPS(Pointer filename, int options);
	/**
	 * Original signature : <code>WINAPI read_freeMPS(char*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3984</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_freeMPS(ByteBuffer filename, int options);
	/**
	 * Original signature : <code>WINAPI read_freemps(FILE*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3986</i><br>
	 * @deprecated use the safer method {@link #read_freemps(com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI read_freemps(Pointer filename, int options);
	/**
	 * Original signature : <code>WINAPI read_freemps(FILE*, int)</code><br>
	 * <i>native declaration : lp_lib.h:3986</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_freemps(PointerByReference filename, int options);
	/**
	 * Original signature : <code>WINAPI write_mps(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3988</i><br>
	 * @deprecated use the safer methods {@link #write_mps(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #write_mps(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI write_mps(lprec lp, Pointer filename);
	/**
	 * Original signature : <code>WINAPI write_mps(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3988</i>
	 */
	public static native LpSolveLibLibrary.WINAPI write_mps(lprec lp, ByteBuffer filename);
	/**
	 * Original signature : <code>WINAPI write_MPS(lprec*, FILE*)</code><br>
	 * <i>native declaration : lp_lib.h:3990</i><br>
	 * @deprecated use the safer method {@link #write_MPS(lpsolvelib.lprec, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI write_MPS(lprec lp, Pointer output);
	/**
	 * Original signature : <code>WINAPI write_MPS(lprec*, FILE*)</code><br>
	 * <i>native declaration : lp_lib.h:3990</i>
	 */
	public static native LpSolveLibLibrary.WINAPI write_MPS(lprec lp, PointerByReference output);
	/**
	 * Original signature : <code>WINAPI write_freemps(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3992</i><br>
	 * @deprecated use the safer methods {@link #write_freemps(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #write_freemps(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI write_freemps(lprec lp, Pointer filename);
	/**
	 * Original signature : <code>WINAPI write_freemps(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3992</i>
	 */
	public static native LpSolveLibLibrary.WINAPI write_freemps(lprec lp, ByteBuffer filename);
	/**
	 * Original signature : <code>WINAPI write_freeMPS(lprec*, FILE*)</code><br>
	 * <i>native declaration : lp_lib.h:3994</i><br>
	 * @deprecated use the safer method {@link #write_freeMPS(lpsolvelib.lprec, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI write_freeMPS(lprec lp, Pointer output);
	/**
	 * Original signature : <code>WINAPI write_freeMPS(lprec*, FILE*)</code><br>
	 * <i>native declaration : lp_lib.h:3994</i>
	 */
	public static native LpSolveLibLibrary.WINAPI write_freeMPS(lprec lp, PointerByReference output);
	/**
	 * Original signature : <code>WINAPI write_lp(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3996</i><br>
	 * @deprecated use the safer methods {@link #write_lp(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #write_lp(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI write_lp(lprec lp, Pointer filename);
	/**
	 * Original signature : <code>WINAPI write_lp(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:3996</i>
	 */
	public static native LpSolveLibLibrary.WINAPI write_lp(lprec lp, ByteBuffer filename);
	/**
	 * Original signature : <code>WINAPI write_LP(lprec*, FILE*)</code><br>
	 * <i>native declaration : lp_lib.h:3998</i><br>
	 * @deprecated use the safer method {@link #write_LP(lpsolvelib.lprec, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI write_LP(lprec lp, Pointer output);
	/**
	 * Original signature : <code>WINAPI write_LP(lprec*, FILE*)</code><br>
	 * <i>native declaration : lp_lib.h:3998</i>
	 */
	public static native LpSolveLibLibrary.WINAPI write_LP(lprec lp, PointerByReference output);
	/**
	 * Original signature : <code>WINAPI LP_readhandle(lprec**, FILE*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4000</i><br>
	 * @deprecated use the safer methods {@link #LP_readhandle(lpsolvelib.lprec.ByReference[], com.sun.jna.ptr.PointerByReference, int, java.nio.ByteBuffer)} and {@link #LP_readhandle(lpsolvelib.lprec.ByReference[], com.sun.jna.ptr.PointerByReference, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI LP_readhandle(PointerByReference lp, Pointer filename, int verbose, Pointer lp_name);
	/**
	 * Original signature : <code>WINAPI LP_readhandle(lprec**, FILE*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4000</i>
	 */
	public static native LpSolveLibLibrary.WINAPI LP_readhandle(lprec.ByReference lp[], PointerByReference filename, int verbose, ByteBuffer lp_name);
	/**
	 * Original signature : <code>WINAPI LP_readhandle(lprec**, FILE*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4000</i>
	 */
	public static native LpSolveLibLibrary.WINAPI LP_readhandle(lprec.ByReference lp[], PointerByReference filename, int verbose, Pointer lp_name);
	/**
	 * Original signature : <code>WINAPI read_lp(FILE*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4002</i><br>
	 * @deprecated use the safer methods {@link #read_lp(com.sun.jna.ptr.PointerByReference, int, java.nio.ByteBuffer)} and {@link #read_lp(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI read_lp(Pointer filename, int verbose, Pointer lp_name);
	/**
	 * Original signature : <code>WINAPI read_lp(FILE*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4002</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_lp(PointerByReference filename, int verbose, ByteBuffer lp_name);
	/**
	 * Original signature : <code>WINAPI read_lp(FILE*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4002</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_lp(PointerByReference filename, int verbose, Pointer lp_name);
	/**
	 * Original signature : <code>WINAPI read_LP(char*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4004</i><br>
	 * @deprecated use the safer methods {@link #read_LP(java.nio.ByteBuffer, int, java.nio.ByteBuffer)} and {@link #read_LP(com.sun.jna.Pointer, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI read_LP(Pointer filename, int verbose, Pointer lp_name);
	/**
	 * Original signature : <code>WINAPI read_LP(char*, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4004</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_LP(ByteBuffer filename, int verbose, ByteBuffer lp_name);
	/**
	 * Original signature : <code>WINAPI write_basis(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4006</i><br>
	 * @deprecated use the safer methods {@link #write_basis(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #write_basis(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI write_basis(lprec lp, Pointer filename);
	/**
	 * Original signature : <code>WINAPI write_basis(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4006</i>
	 */
	public static native LpSolveLibLibrary.WINAPI write_basis(lprec lp, ByteBuffer filename);
	/**
	 * Original signature : <code>WINAPI read_basis(lprec*, char*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4008</i><br>
	 * @deprecated use the safer methods {@link #read_basis(lpsolvelib.lprec, java.nio.ByteBuffer, java.nio.ByteBuffer)} and {@link #read_basis(lpsolvelib.lprec, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI read_basis(lprec lp, Pointer filename, Pointer info);
	/**
	 * Original signature : <code>WINAPI read_basis(lprec*, char*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4008</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_basis(lprec lp, ByteBuffer filename, ByteBuffer info);
	/**
	 * Original signature : <code>WINAPI write_params(lprec*, char*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4010</i><br>
	 * @deprecated use the safer methods {@link #write_params(lpsolvelib.lprec, java.nio.ByteBuffer, java.nio.ByteBuffer)} and {@link #write_params(lpsolvelib.lprec, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI write_params(lprec lp, Pointer filename, Pointer options);
	/**
	 * Original signature : <code>WINAPI write_params(lprec*, char*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4010</i>
	 */
	public static native LpSolveLibLibrary.WINAPI write_params(lprec lp, ByteBuffer filename, ByteBuffer options);
	/**
	 * Original signature : <code>WINAPI read_params(lprec*, char*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4012</i><br>
	 * @deprecated use the safer methods {@link #read_params(lpsolvelib.lprec, java.nio.ByteBuffer, java.nio.ByteBuffer)} and {@link #read_params(lpsolvelib.lprec, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI read_params(lprec lp, Pointer filename, Pointer options);
	/**
	 * Original signature : <code>WINAPI read_params(lprec*, char*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4012</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_params(lprec lp, ByteBuffer filename, ByteBuffer options);
	/**
	 * Original signature : <code>WINAPI reset_params(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4014</i>
	 */
	public static native LpSolveLibLibrary.WINAPI reset_params(lprec lp);
	/**
	 * Original signature : <code>WINAPI print_lp(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4016</i>
	 */
	public static native LpSolveLibLibrary.WINAPI print_lp(lprec lp);
	/**
	 * Original signature : <code>WINAPI print_tableau(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4018</i>
	 */
	public static native LpSolveLibLibrary.WINAPI print_tableau(lprec lp);
	/**
	 * Original signature : <code>WINAPI print_objective(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4020</i>
	 */
	public static native LpSolveLibLibrary.WINAPI print_objective(lprec lp);
	/**
	 * Original signature : <code>WINAPI print_solution(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4022</i>
	 */
	public static native LpSolveLibLibrary.WINAPI print_solution(lprec lp, int columns);
	/**
	 * Original signature : <code>WINAPI print_constraints(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4024</i>
	 */
	public static native LpSolveLibLibrary.WINAPI print_constraints(lprec lp, int columns);
	/**
	 * Original signature : <code>WINAPI print_duals(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4026</i>
	 */
	public static native LpSolveLibLibrary.WINAPI print_duals(lprec lp);
	/**
	 * Original signature : <code>WINAPI print_scales(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4028</i>
	 */
	public static native LpSolveLibLibrary.WINAPI print_scales(lprec lp);
	/**
	 * Original signature : <code>WINAPI print_str(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4030</i><br>
	 * @deprecated use the safer methods {@link #print_str(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #print_str(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI print_str(lprec lp, Pointer str);
	/**
	 * Original signature : <code>WINAPI print_str(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4030</i>
	 */
	public static native LpSolveLibLibrary.WINAPI print_str(lprec lp, ByteBuffer str);
	/**
	 * Original signature : <code>WINAPI set_outputstream(lprec*, FILE*)</code><br>
	 * <i>native declaration : lp_lib.h:4032</i><br>
	 * @deprecated use the safer method {@link #set_outputstream(lpsolvelib.lprec, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_outputstream(lprec lp, Pointer stream);
	/**
	 * Original signature : <code>WINAPI set_outputstream(lprec*, FILE*)</code><br>
	 * <i>native declaration : lp_lib.h:4032</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_outputstream(lprec lp, PointerByReference stream);
	/**
	 * Original signature : <code>WINAPI set_outputfile(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4034</i><br>
	 * @deprecated use the safer methods {@link #set_outputfile(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #set_outputfile(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_outputfile(lprec lp, Pointer filename);
	/**
	 * Original signature : <code>WINAPI set_outputfile(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4034</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_outputfile(lprec lp, ByteBuffer filename);
	/**
	 * Original signature : <code>WINAPI set_verbose(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4036</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_verbose(lprec lp, int verbose);
	/**
	 * Original signature : <code>WINAPI get_verbose(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4038</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_verbose(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_timeout(lprec*, long)</code><br>
	 * <i>native declaration : lp_lib.h:4040</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_timeout(lprec lp, NativeLong sectimeout);
	/**
	 * Original signature : <code>long WINAPI get_timeout(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4042</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_timeout(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_print_sol(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4044</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_print_sol(lprec lp, int print_sol);
	/**
	 * Original signature : <code>WINAPI get_print_sol(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4046</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_print_sol(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_debug(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4048</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_debug(lprec lp, byte debug);
	/**
	 * Original signature : <code>WINAPI is_debug(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4050</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_debug(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_trace(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4052</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_trace(lprec lp, byte trace);
	/**
	 * Original signature : <code>WINAPI is_trace(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4054</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_trace(lprec lp);
	/**
	 * Original signature : <code>WINAPI print_debugdump(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4056</i><br>
	 * @deprecated use the safer methods {@link #print_debugdump(lpsolvelib.lprec, java.nio.ByteBuffer)} and {@link #print_debugdump(lpsolvelib.lprec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI print_debugdump(lprec lp, Pointer filename);
	/**
	 * Original signature : <code>WINAPI print_debugdump(lprec*, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4056</i>
	 */
	public static native LpSolveLibLibrary.WINAPI print_debugdump(lprec lp, ByteBuffer filename);
	/**
	 * Original signature : <code>WINAPI set_anti_degen(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4058</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_anti_degen(lprec lp, int anti_degen);
	/**
	 * Original signature : <code>WINAPI get_anti_degen(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4060</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_anti_degen(lprec lp);
	/**
	 * Original signature : <code>WINAPI is_anti_degen(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4062</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_anti_degen(lprec lp, int testmask);
	/**
	 * Original signature : <code>WINAPI set_presolve(lprec*, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:4064</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_presolve(lprec lp, int presolvemode, int maxloops);
	/**
	 * Original signature : <code>WINAPI get_presolve(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4066</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_presolve(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_presolveloops(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4068</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_presolveloops(lprec lp);
	/**
	 * Original signature : <code>WINAPI is_presolve(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4070</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_presolve(lprec lp, int testmask);
	/**
	 * Original signature : <code>WINAPI get_orig_index(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4072</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_orig_index(lprec lp, int lp_index);
	/**
	 * Original signature : <code>WINAPI get_lp_index(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4074</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_lp_index(lprec lp, int orig_index);
	/**
	 * Original signature : <code>WINAPI set_maxpivot(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4076</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_maxpivot(lprec lp, int max_num_inv);
	/**
	 * Original signature : <code>WINAPI get_maxpivot(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4078</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_maxpivot(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_obj_bound(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4080</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_obj_bound(lprec lp, double obj_bound);
	/**
	 * Original signature : <code>WINAPI get_obj_bound(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4082</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_obj_bound(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_mip_gap(lprec*, unsigned char, double)</code><br>
	 * <i>native declaration : lp_lib.h:4084</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_mip_gap(lprec lp, byte absolute, double mip_gap);
	/**
	 * Original signature : <code>WINAPI get_mip_gap(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4086</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_mip_gap(lprec lp, byte absolute);
	/**
	 * Original signature : <code>WINAPI set_bb_rule(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4088</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_bb_rule(lprec lp, int bb_rule);
	/**
	 * Original signature : <code>WINAPI get_bb_rule(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4090</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_bb_rule(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_var_branch(lprec*, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:4092</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_var_branch(lprec lp, int colnr, int branch_mode);
	/**
	 * Original signature : <code>WINAPI get_var_branch(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4094</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_var_branch(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI is_infinite(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4096</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_infinite(lprec lp, double value);
	/**
	 * Original signature : <code>WINAPI set_infinite(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4098</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_infinite(lprec lp, double infinite);
	/**
	 * Original signature : <code>WINAPI get_infinite(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4100</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_infinite(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_epsint(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4102</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_epsint(lprec lp, double epsint);
	/**
	 * Original signature : <code>WINAPI get_epsint(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4104</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_epsint(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_epsb(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4106</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_epsb(lprec lp, double epsb);
	/**
	 * Original signature : <code>WINAPI get_epsb(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4108</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_epsb(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_epsd(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4110</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_epsd(lprec lp, double epsd);
	/**
	 * Original signature : <code>WINAPI get_epsd(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4112</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_epsd(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_epsel(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4114</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_epsel(lprec lp, double epsel);
	/**
	 * Original signature : <code>WINAPI get_epsel(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4116</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_epsel(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_epslevel(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4118</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_epslevel(lprec lp, int epslevel);
	/**
	 * Original signature : <code>WINAPI set_scaling(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4120</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_scaling(lprec lp, int scalemode);
	/**
	 * Original signature : <code>WINAPI get_scaling(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4122</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_scaling(lprec lp);
	/**
	 * Original signature : <code>WINAPI is_scalemode(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4124</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_scalemode(lprec lp, int testmask);
	/**
	 * Original signature : <code>WINAPI is_scaletype(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4126</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_scaletype(lprec lp, int scaletype);
	/**
	 * Original signature : <code>WINAPI is_integerscaling(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4128</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_integerscaling(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_scalelimit(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4130</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_scalelimit(lprec lp, double scalelimit);
	/**
	 * Original signature : <code>WINAPI get_scalelimit(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4132</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_scalelimit(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_improve(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4134</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_improve(lprec lp, int improve);
	/**
	 * Original signature : <code>WINAPI get_improve(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4136</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_improve(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_pivoting(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4138</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_pivoting(lprec lp, int piv_rule);
	/**
	 * Original signature : <code>WINAPI get_pivoting(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4140</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_pivoting(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_partialprice(lprec*, int, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4142</i><br>
	 * @deprecated use the safer methods {@link #set_partialprice(lpsolvelib.lprec, int, java.nio.IntBuffer, byte)} and {@link #set_partialprice(lpsolvelib.lprec, int, com.sun.jna.ptr.IntByReference, byte)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_partialprice(lprec lp, int blockcount, IntByReference blockstart, byte isrow);
	/**
	 * Original signature : <code>WINAPI set_partialprice(lprec*, int, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4142</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_partialprice(lprec lp, int blockcount, IntBuffer blockstart, byte isrow);
	/**
	 * Original signature : <code>WINAPI get_partialprice(lprec*, int*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4144</i><br>
	 * @deprecated use the safer methods {@link #get_partialprice(lpsolvelib.lprec, java.nio.IntBuffer, java.nio.IntBuffer, byte)} and {@link #get_partialprice(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, byte)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_partialprice(lprec lp, IntByReference blockcount, IntByReference blockstart, byte isrow);
	/**
	 * Original signature : <code>WINAPI get_partialprice(lprec*, int*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4144</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_partialprice(lprec lp, IntBuffer blockcount, IntBuffer blockstart, byte isrow);
	/**
	 * Original signature : <code>WINAPI set_multiprice(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4146</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_multiprice(lprec lp, int multiblockdiv);
	/**
	 * Original signature : <code>WINAPI get_multiprice(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4148</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_multiprice(lprec lp, byte getabssize);
	/**
	 * Original signature : <code>WINAPI is_use_names(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4150</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_use_names(lprec lp, byte isrow);
	/**
	 * Original signature : <code>WINAPI set_use_names(lprec*, unsigned char, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4152</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_use_names(lprec lp, byte isrow, byte use_names);
	/**
	 * Original signature : <code>WINAPI get_nameindex(lprec*, char*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4154</i><br>
	 * @deprecated use the safer methods {@link #get_nameindex(lpsolvelib.lprec, java.nio.ByteBuffer, byte)} and {@link #get_nameindex(lpsolvelib.lprec, com.sun.jna.Pointer, byte)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_nameindex(lprec lp, Pointer varname, byte isrow);
	/**
	 * Original signature : <code>WINAPI get_nameindex(lprec*, char*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4154</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_nameindex(lprec lp, ByteBuffer varname, byte isrow);
	/**
	 * Original signature : <code>WINAPI is_piv_mode(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4156</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_piv_mode(lprec lp, int testmask);
	/**
	 * Original signature : <code>WINAPI is_piv_rule(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4158</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_piv_rule(lprec lp, int rule);
	/**
	 * Original signature : <code>WINAPI set_break_at_first(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4160</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_break_at_first(lprec lp, byte break_at_first);
	/**
	 * Original signature : <code>WINAPI is_break_at_first(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4162</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_break_at_first(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_bb_floorfirst(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4164</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_bb_floorfirst(lprec lp, int bb_floorfirst);
	/**
	 * Original signature : <code>WINAPI get_bb_floorfirst(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4166</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_bb_floorfirst(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_bb_depthlimit(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4168</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_bb_depthlimit(lprec lp, int bb_maxlevel);
	/**
	 * Original signature : <code>WINAPI get_bb_depthlimit(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4170</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_bb_depthlimit(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_break_at_value(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4172</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_break_at_value(lprec lp, double break_at_value);
	/**
	 * Original signature : <code>WINAPI get_break_at_value(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4174</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_break_at_value(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_negrange(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4176</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_negrange(lprec lp, double negrange);
	/**
	 * Original signature : <code>WINAPI get_negrange(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4178</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_negrange(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_epsperturb(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4180</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_epsperturb(lprec lp, double epsperturb);
	/**
	 * Original signature : <code>WINAPI get_epsperturb(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4182</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_epsperturb(lprec lp);
	/**
	 * Original signature : <code>WINAPI set_epspivot(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4184</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_epspivot(lprec lp, double epspivot);
	/**
	 * Original signature : <code>WINAPI get_epspivot(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4186</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_epspivot(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_max_level(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4188</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_max_level(lprec lp);
	/**
	 * Original signature : <code>long long WINAPI get_total_nodes(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4190</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_total_nodes(lprec lp);
	/**
	 * Original signature : <code>long long WINAPI get_total_iter(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4192</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_total_iter(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_objective(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4194</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_objective(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_working_objective(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4196</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_working_objective(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_var_primalresult(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4198</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_var_primalresult(lprec lp, int index);
	/**
	 * Original signature : <code>WINAPI get_var_dualresult(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4200</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_var_dualresult(lprec lp, int index);
	/**
	 * Original signature : <code>WINAPI get_variables(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4202</i><br>
	 * @deprecated use the safer methods {@link #get_variables(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #get_variables(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_variables(lprec lp, DoubleByReference var);
	/**
	 * Original signature : <code>WINAPI get_variables(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4202</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_variables(lprec lp, DoubleBuffer var);
	/**
	 * Original signature : <code>WINAPI get_ptr_variables(lprec*, double**)</code><br>
	 * <i>native declaration : lp_lib.h:4204</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_ptr_variables(lprec lp, PointerByReference var);
	/**
	 * Original signature : <code>WINAPI get_constraints(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4206</i><br>
	 * @deprecated use the safer methods {@link #get_constraints(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #get_constraints(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_constraints(lprec lp, DoubleByReference constr);
	/**
	 * Original signature : <code>WINAPI get_constraints(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4206</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_constraints(lprec lp, DoubleBuffer constr);
	/**
	 * Original signature : <code>WINAPI get_ptr_constraints(lprec*, double**)</code><br>
	 * <i>native declaration : lp_lib.h:4208</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_ptr_constraints(lprec lp, PointerByReference constr);
	/**
	 * Original signature : <code>WINAPI get_sensitivity_rhs(lprec*, double*, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4210</i><br>
	 * @deprecated use the safer methods {@link #get_sensitivity_rhs(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.DoubleBuffer)} and {@link #get_sensitivity_rhs(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_sensitivity_rhs(lprec lp, DoubleByReference duals, DoubleByReference dualsfrom, DoubleByReference dualstill);
	/**
	 * Original signature : <code>WINAPI get_sensitivity_rhs(lprec*, double*, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4210</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_sensitivity_rhs(lprec lp, DoubleBuffer duals, DoubleBuffer dualsfrom, DoubleBuffer dualstill);
	/**
	 * Original signature : <code>WINAPI get_ptr_sensitivity_rhs(lprec*, double**, double**, double**)</code><br>
	 * <i>native declaration : lp_lib.h:4212</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_ptr_sensitivity_rhs(lprec lp, PointerByReference duals, PointerByReference dualsfrom, PointerByReference dualstill);
	/**
	 * Original signature : <code>WINAPI get_sensitivity_obj(lprec*, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4214</i><br>
	 * @deprecated use the safer methods {@link #get_sensitivity_obj(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.DoubleBuffer)} and {@link #get_sensitivity_obj(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_sensitivity_obj(lprec lp, DoubleByReference objfrom, DoubleByReference objtill);
	/**
	 * Original signature : <code>WINAPI get_sensitivity_obj(lprec*, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4214</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_sensitivity_obj(lprec lp, DoubleBuffer objfrom, DoubleBuffer objtill);
	/**
	 * Original signature : <code>WINAPI get_sensitivity_objex(lprec*, double*, double*, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4216</i><br>
	 * @deprecated use the safer methods {@link #get_sensitivity_objex(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.DoubleBuffer)} and {@link #get_sensitivity_objex(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_sensitivity_objex(lprec lp, DoubleByReference objfrom, DoubleByReference objtill, DoubleByReference objfromvalue, DoubleByReference objtillvalue);
	/**
	 * Original signature : <code>WINAPI get_sensitivity_objex(lprec*, double*, double*, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4216</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_sensitivity_objex(lprec lp, DoubleBuffer objfrom, DoubleBuffer objtill, DoubleBuffer objfromvalue, DoubleBuffer objtillvalue);
	/**
	 * Original signature : <code>WINAPI get_ptr_sensitivity_obj(lprec*, double**, double**)</code><br>
	 * <i>native declaration : lp_lib.h:4218</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_ptr_sensitivity_obj(lprec lp, PointerByReference objfrom, PointerByReference objtill);
	/**
	 * Original signature : <code>WINAPI get_ptr_sensitivity_objex(lprec*, double**, double**, double**, double**)</code><br>
	 * <i>native declaration : lp_lib.h:4220</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_ptr_sensitivity_objex(lprec lp, PointerByReference objfrom, PointerByReference objtill, PointerByReference objfromvalue, PointerByReference objtillvalue);
	/**
	 * Original signature : <code>WINAPI set_solutionlimit(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4222</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_solutionlimit(lprec lp, int limit);
	/**
	 * Original signature : <code>WINAPI get_solutionlimit(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4224</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_solutionlimit(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_solutioncount(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4226</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_solutioncount(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_Norig_rows(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4228</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_Norig_rows(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_Nrows(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4230</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_Nrows(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_Lrows(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4232</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_Lrows(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_Norig_columns(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4234</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_Norig_columns(lprec lp);
	/**
	 * Original signature : <code>WINAPI get_Ncolumns(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4236</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_Ncolumns(lprec lp);
	/**
	 * Original signature : <code>WINAPI MPS_readex(lprec**, void*, read_modeldata_func, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:4240</i><br>
	 * @deprecated use the safer method {@link #MPS_readex(lpsolvelib.lprec.ByReference[], com.sun.jna.Pointer, lpsolvelib.LpSolveLibLibrary.read_modeldata_func, int, int)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI MPS_readex(PointerByReference newlp, Pointer userhandle, LpSolveLibLibrary.read_modeldata_func read_modeldata, int typeMPS, int options);
	/**
	 * Original signature : <code>WINAPI MPS_readex(lprec**, void*, read_modeldata_func, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:4240</i>
	 */
	public static native LpSolveLibLibrary.WINAPI MPS_readex(lprec.ByReference newlp[], Pointer userhandle, LpSolveLibLibrary.read_modeldata_func read_modeldata, int typeMPS, int options);
	/**
	 * Original signature : <code>WINAPI read_lpex(void*, read_modeldata_func, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4242</i><br>
	 * @deprecated use the safer methods {@link #read_lpex(com.sun.jna.Pointer, lpsolvelib.LpSolveLibLibrary.read_modeldata_func, int, java.nio.ByteBuffer)} and {@link #read_lpex(com.sun.jna.Pointer, lpsolvelib.LpSolveLibLibrary.read_modeldata_func, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI read_lpex(Pointer userhandle, LpSolveLibLibrary.read_modeldata_func read_modeldata, int verbose, Pointer lp_name);
	/**
	 * Original signature : <code>WINAPI read_lpex(void*, read_modeldata_func, int, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4242</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_lpex(Pointer userhandle, LpSolveLibLibrary.read_modeldata_func read_modeldata, int verbose, ByteBuffer lp_name);
	/**
	 * Original signature : <code>WINAPI write_lpex(lprec*, void*, write_modeldata_func)</code><br>
	 * <i>native declaration : lp_lib.h:4244</i>
	 */
	public static native LpSolveLibLibrary.WINAPI write_lpex(lprec lp, Pointer userhandle, LpSolveLibLibrary.write_modeldata_func write_modeldata);
	/**
	 * Original signature : <code>WINAPI read_mpsex(void*, read_modeldata_func, int)</code><br>
	 * <i>native declaration : lp_lib.h:4246</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_mpsex(Pointer userhandle, LpSolveLibLibrary.read_modeldata_func read_modeldata, int options);
	/**
	 * Original signature : <code>WINAPI read_freempsex(void*, read_modeldata_func, int)</code><br>
	 * <i>native declaration : lp_lib.h:4248</i>
	 */
	public static native LpSolveLibLibrary.WINAPI read_freempsex(Pointer userhandle, LpSolveLibLibrary.read_modeldata_func read_modeldata, int options);
	/**
	 * Original signature : <code>WINAPI MPS_writefileex(lprec*, int, void*, write_modeldata_func)</code><br>
	 * <i>native declaration : lp_lib.h:4250</i>
	 */
	public static native LpSolveLibLibrary.WINAPI MPS_writefileex(lprec lp, int typeMPS, Pointer userhandle, LpSolveLibLibrary.write_modeldata_func write_modeldata);
	/**
	 * Forward definitions of functions used internaly by the lp toolkit<br>
	 * Original signature : <code>char set_callbacks(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4255</i>
	 */
	public static native byte set_callbacks(lprec lp);
	/**
	 * Original signature : <code>int yieldformessages(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4257</i>
	 */
	public static native int yieldformessages(lprec lp);
	/**
	 * Original signature : <code>WINAPI userabort(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4259</i>
	 */
	public static native LpSolveLibLibrary.WINAPI userabort(lprec lp, int message);
	/**
	 * Memory management routines<br>
	 * Original signature : <code>char append_rows(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4264</i>
	 */
	public static native byte append_rows(lprec lp, int deltarows);
	/**
	 * Original signature : <code>char append_columns(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4266</i>
	 */
	public static native byte append_columns(lprec lp, int deltacolumns);
	/**
	 * Original signature : <code>void inc_rows(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4268</i>
	 */
	public static native void inc_rows(lprec lp, int delta);
	/**
	 * Original signature : <code>void inc_columns(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4270</i>
	 */
	public static native void inc_columns(lprec lp, int delta);
	/**
	 * Original signature : <code>char init_rowcol_names(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4272</i>
	 */
	public static native byte init_rowcol_names(lprec lp);
	/**
	 * Original signature : <code>char inc_row_space(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4274</i>
	 */
	public static native byte inc_row_space(lprec lp, int deltarows);
	/**
	 * Original signature : <code>char inc_col_space(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4276</i>
	 */
	public static native byte inc_col_space(lprec lp, int deltacols);
	/**
	 * Original signature : <code>char shift_rowcoldata(lprec*, int, int, LLrec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4278</i>
	 */
	public static native byte shift_rowcoldata(lprec lp, int base, int delta, LLrec usedmap, byte isrow);
	/**
	 * Original signature : <code>char shift_basis(lprec*, int, int, LLrec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4280</i>
	 */
	public static native byte shift_basis(lprec lp, int base, int delta, LLrec usedmap, byte isrow);
	/**
	 * Original signature : <code>char shift_rowdata(lprec*, int, int, LLrec*)</code><br>
	 * <i>native declaration : lp_lib.h:4282</i>
	 */
	public static native byte shift_rowdata(lprec lp, int base, int delta, LLrec usedmap);
	/**
	 * Original signature : <code>char shift_coldata(lprec*, int, int, LLrec*)</code><br>
	 * <i>native declaration : lp_lib.h:4284</i>
	 */
	public static native byte shift_coldata(lprec lp, int base, int delta, LLrec usedmap);
	/**
	 * INLINE<br>
	 * Original signature : <code>char is_chsign(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4289</i>
	 */
	public static native byte is_chsign(lprec lp, int rownr);
	/**
	 * Original signature : <code>char inc_lag_space(lprec*, int, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4291</i>
	 */
	public static native byte inc_lag_space(lprec lp, int deltarows, byte ignoreMAT);
	/**
	 * Original signature : <code>lprec* make_lag(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4293</i>
	 */
	public static native lprec make_lag(lprec server);
	/**
	 * Original signature : <code>double get_rh_upper(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4295</i>
	 */
	public static native double get_rh_upper(lprec lp, int rownr);
	/**
	 * Original signature : <code>double get_rh_lower(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4297</i>
	 */
	public static native double get_rh_lower(lprec lp, int rownr);
	/**
	 * Original signature : <code>char set_rh_upper(lprec*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:4299</i>
	 */
	public static native byte set_rh_upper(lprec lp, int rownr, double value);
	/**
	 * Original signature : <code>char set_rh_lower(lprec*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:4301</i>
	 */
	public static native byte set_rh_lower(lprec lp, int rownr, double value);
	/**
	 * Original signature : <code>int bin_count(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4303</i>
	 */
	public static native int bin_count(lprec lp, byte working);
	/**
	 * Original signature : <code>int MIP_count(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4305</i>
	 */
	public static native int MIP_count(lprec lp);
	/**
	 * Original signature : <code>int SOS_count(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4307</i>
	 */
	public static native int SOS_count(lprec lp);
	/**
	 * Original signature : <code>int GUB_count(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4309</i>
	 */
	public static native int GUB_count(lprec lp);
	/**
	 * Original signature : <code>int identify_GUB(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4311</i>
	 */
	public static native int identify_GUB(lprec lp, byte mark);
	/**
	 * Original signature : <code>int prepare_GUB(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4313</i>
	 */
	public static native int prepare_GUB(lprec lp);
	/**
	 * Original signature : <code>char refactRecent(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4315</i>
	 */
	public static native byte refactRecent(lprec lp);
	/**
	 * Original signature : <code>char check_if_less(lprec*, double, double, int)</code><br>
	 * <i>native declaration : lp_lib.h:4317</i>
	 */
	public static native byte check_if_less(lprec lp, double x, double y, int variable);
	/**
	 * Original signature : <code>char feasiblePhase1(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4319</i>
	 */
	public static native byte feasiblePhase1(lprec lp, double epsvalue);
	/**
	 * Original signature : <code>void free_duals(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4321</i>
	 */
	public static native void free_duals(lprec lp);
	/**
	 * Original signature : <code>void initialize_solution(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4323</i>
	 */
	public static native void initialize_solution(lprec lp, byte shiftbounds);
	/**
	 * Original signature : <code>void recompute_solution(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4325</i>
	 */
	public static native void recompute_solution(lprec lp, byte shiftbounds);
	/**
	 * Original signature : <code>int verify_solution(lprec*, unsigned char, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4327</i><br>
	 * @deprecated use the safer methods {@link #verify_solution(lpsolvelib.lprec, byte, java.nio.ByteBuffer)} and {@link #verify_solution(lpsolvelib.lprec, byte, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native int verify_solution(lprec lp, byte reinvert, Pointer info);
	/**
	 * Original signature : <code>int verify_solution(lprec*, unsigned char, char*)</code><br>
	 * <i>native declaration : lp_lib.h:4327</i>
	 */
	public static native int verify_solution(lprec lp, byte reinvert, ByteBuffer info);
	/**
	 * Original signature : <code>int check_solution(lprec*, int, double*, double*, double*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4329</i><br>
	 * @deprecated use the safer methods {@link #check_solution(lpsolvelib.lprec, int, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.DoubleBuffer, double)} and {@link #check_solution(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference, double)} instead
	 */
	@Deprecated 
	public static native int check_solution(lprec lp, int lastcolumn, DoubleByReference solution, DoubleByReference upbo, DoubleByReference lowbo, double tolerance);
	/**
	 * Original signature : <code>int check_solution(lprec*, int, double*, double*, double*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4329</i>
	 */
	public static native int check_solution(lprec lp, int lastcolumn, DoubleBuffer solution, DoubleBuffer upbo, DoubleBuffer lowbo, double tolerance);
	/**
	 * INLINE<br>
	 * Original signature : <code>char is_fixedvar(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4334</i>
	 */
	public static native byte is_fixedvar(lprec lp, int variable);
	/**
	 * INLINE<br>
	 * Original signature : <code>char is_splitvar(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4339</i>
	 */
	public static native byte is_splitvar(lprec lp, int colnr);
	/**
	 * Original signature : <code>WINAPI set_action(int*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4341</i><br>
	 * @deprecated use the safer methods {@link #set_action(java.nio.IntBuffer, int)} and {@link #set_action(com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI set_action(IntByReference actionvar, int actionmask);
	/**
	 * Original signature : <code>WINAPI set_action(int*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4341</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_action(IntBuffer actionvar, int actionmask);
	/**
	 * Original signature : <code>WINAPI clear_action(int*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4343</i><br>
	 * @deprecated use the safer methods {@link #clear_action(java.nio.IntBuffer, int)} and {@link #clear_action(com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI clear_action(IntByReference actionvar, int actionmask);
	/**
	 * Original signature : <code>WINAPI clear_action(int*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4343</i>
	 */
	public static native LpSolveLibLibrary.WINAPI clear_action(IntBuffer actionvar, int actionmask);
	/**
	 * Original signature : <code>WINAPI is_action(int, int)</code><br>
	 * <i>native declaration : lp_lib.h:4345</i>
	 */
	public static native LpSolveLibLibrary.WINAPI is_action(int actionvar, int testmask);
	/**
	 * INLINE<br>
	 * Original signature : <code>char is_bb_rule(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4350</i>
	 */
	public static native byte is_bb_rule(lprec lp, int bb_rule);
	/**
	 * INLINE<br>
	 * Original signature : <code>char is_bb_mode(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4355</i>
	 */
	public static native byte is_bb_mode(lprec lp, int bb_mask);
	/**
	 * INLINE<br>
	 * Original signature : <code>int get_piv_rule(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4360</i>
	 */
	public static native int get_piv_rule(lprec lp);
	/**
	 * Original signature : <code>char* get_str_piv_rule(int)</code><br>
	 * <i>native declaration : lp_lib.h:4362</i>
	 */
	public static native Pointer get_str_piv_rule(int rule);
	/**
	 * Original signature : <code>WINAPI set_var_priority(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4364</i>
	 */
	public static native LpSolveLibLibrary.WINAPI set_var_priority(lprec lp);
	/**
	 * Original signature : <code>int find_sc_bbvar(lprec*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4366</i><br>
	 * @deprecated use the safer methods {@link #find_sc_bbvar(lpsolvelib.lprec, java.nio.IntBuffer)} and {@link #find_sc_bbvar(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native int find_sc_bbvar(lprec lp, IntByReference count);
	/**
	 * Original signature : <code>int find_sc_bbvar(lprec*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4366</i>
	 */
	public static native int find_sc_bbvar(lprec lp, IntBuffer count);
	/**
	 * Original signature : <code>int find_sos_bbvar(lprec*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4368</i><br>
	 * @deprecated use the safer methods {@link #find_sos_bbvar(lpsolvelib.lprec, java.nio.IntBuffer, byte)} and {@link #find_sos_bbvar(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, byte)} instead
	 */
	@Deprecated 
	public static native int find_sos_bbvar(lprec lp, IntByReference count, byte intsos);
	/**
	 * Original signature : <code>int find_sos_bbvar(lprec*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4368</i>
	 */
	public static native int find_sos_bbvar(lprec lp, IntBuffer count, byte intsos);
	/**
	 * Original signature : <code>int find_int_bbvar(lprec*, int*, BBrec*, unsigned char*)</code><br>
	 * <i>native declaration : lp_lib.h:4370</i><br>
	 * @deprecated use the safer methods {@link #find_int_bbvar(lpsolvelib.lprec, java.nio.IntBuffer, lpsolvemipbb.BBrec, java.nio.ByteBuffer)} and {@link #find_int_bbvar(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, lpsolvemipbb.BBrec, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native int find_int_bbvar(lprec lp, IntByReference count, BBrec BB, Pointer isfeasible);
	/**
	 * Original signature : <code>int find_int_bbvar(lprec*, int*, BBrec*, unsigned char*)</code><br>
	 * <i>native declaration : lp_lib.h:4370</i>
	 */
	public static native int find_int_bbvar(lprec lp, IntBuffer count, BBrec BB, ByteBuffer isfeasible);
	/**
	 * Solution-related functions<br>
	 * Original signature : <code>double compute_dualslacks(lprec*, int, double**, int**, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4375</i>
	 */
	public static native double compute_dualslacks(lprec lp, int target, PointerByReference dvalues, PointerByReference nzdvalues, byte dosum);
	/**
	 * Original signature : <code>char solution_is_int(lprec*, int, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4377</i>
	 */
	public static native byte solution_is_int(lprec lp, int index, byte checkfixed);
	/**
	 * Original signature : <code>char bb_better(lprec*, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:4379</i>
	 */
	public static native byte bb_better(lprec lp, int target, int mode);
	/**
	 * Original signature : <code>void construct_solution(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4381</i><br>
	 * @deprecated use the safer methods {@link #construct_solution(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #construct_solution(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native void construct_solution(lprec lp, DoubleByReference target);
	/**
	 * Original signature : <code>void construct_solution(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4381</i>
	 */
	public static native void construct_solution(lprec lp, DoubleBuffer target);
	/**
	 * Original signature : <code>void transfer_solution_var(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4383</i>
	 */
	public static native void transfer_solution_var(lprec lp, int uservar);
	/**
	 * Original signature : <code>char construct_duals(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4385</i>
	 */
	public static native byte construct_duals(lprec lp);
	/**
	 * Original signature : <code>char construct_sensitivity_duals(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4387</i>
	 */
	public static native byte construct_sensitivity_duals(lprec lp);
	/**
	 * Original signature : <code>char construct_sensitivity_obj(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4389</i>
	 */
	public static native byte construct_sensitivity_obj(lprec lp);
	/**
	 * Original signature : <code>int add_GUB(lprec*, char*, int, int, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4391</i><br>
	 * @deprecated use the safer methods {@link #add_GUB(lpsolvelib.lprec, java.nio.ByteBuffer, int, int, java.nio.IntBuffer)} and {@link #add_GUB(lpsolvelib.lprec, com.sun.jna.Pointer, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native int add_GUB(lprec lp, Pointer name, int priority, int count, IntByReference sosvars);
	/**
	 * Original signature : <code>int add_GUB(lprec*, char*, int, int, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4391</i>
	 */
	public static native int add_GUB(lprec lp, ByteBuffer name, int priority, int count, IntBuffer sosvars);
	/**
	 * Original signature : <code>basisrec* push_basis(lprec*, int*, unsigned char*, unsigned char*)</code><br>
	 * <i>native declaration : lp_lib.h:4393</i><br>
	 * @deprecated use the safer methods {@link #push_basis(lpsolvelib.lprec, java.nio.IntBuffer, java.nio.ByteBuffer, java.nio.ByteBuffer)} and {@link #push_basis(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native basisrec push_basis(lprec lp, IntByReference basisvar, Pointer isbasic, Pointer islower);
	/**
	 * Original signature : <code>basisrec* push_basis(lprec*, int*, unsigned char*, unsigned char*)</code><br>
	 * <i>native declaration : lp_lib.h:4393</i>
	 */
	public static native basisrec push_basis(lprec lp, IntBuffer basisvar, ByteBuffer isbasic, ByteBuffer islower);
	/**
	 * Original signature : <code>char compare_basis(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4395</i>
	 */
	public static native byte compare_basis(lprec lp);
	/**
	 * Original signature : <code>char restore_basis(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4397</i>
	 */
	public static native byte restore_basis(lprec lp);
	/**
	 * Original signature : <code>char pop_basis(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4399</i>
	 */
	public static native byte pop_basis(lprec lp, byte restore);
	/**
	 * Original signature : <code>char is_BasisReady(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4401</i>
	 */
	public static native byte is_BasisReady(lprec lp);
	/**
	 * Original signature : <code>char is_slackbasis(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4403</i>
	 */
	public static native byte is_slackbasis(lprec lp);
	/**
	 * Original signature : <code>char verify_basis(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4405</i>
	 */
	public static native byte verify_basis(lprec lp);
	/**
	 * Original signature : <code>int unload_basis(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4407</i>
	 */
	public static native int unload_basis(lprec lp, byte restorelast);
	/**
	 * Original signature : <code>int perturb_bounds(lprec*, BBrec*, unsigned char, unsigned char, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4409</i>
	 */
	public static native int perturb_bounds(lprec lp, BBrec perturbed, byte doRows, byte doCols, byte includeFIXED);
	/**
	 * Original signature : <code>char validate_bounds(lprec*, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4411</i><br>
	 * @deprecated use the safer methods {@link #validate_bounds(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.DoubleBuffer)} and {@link #validate_bounds(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native byte validate_bounds(lprec lp, DoubleByReference upbo, DoubleByReference lowbo);
	/**
	 * Original signature : <code>char validate_bounds(lprec*, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4411</i>
	 */
	public static native byte validate_bounds(lprec lp, DoubleBuffer upbo, DoubleBuffer lowbo);
	/**
	 * Original signature : <code>char impose_bounds(lprec*, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4413</i><br>
	 * @deprecated use the safer methods {@link #impose_bounds(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.DoubleBuffer)} and {@link #impose_bounds(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native byte impose_bounds(lprec lp, DoubleByReference upbo, DoubleByReference lowbo);
	/**
	 * Original signature : <code>char impose_bounds(lprec*, double*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4413</i>
	 */
	public static native byte impose_bounds(lprec lp, DoubleBuffer upbo, DoubleBuffer lowbo);
	/**
	 * Original signature : <code>int unload_BB(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4415</i>
	 */
	public static native int unload_BB(lprec lp);
	/**
	 * Original signature : <code>double feasibilityOffset(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4417</i>
	 */
	public static native double feasibilityOffset(lprec lp, byte isdual);
	/**
	 * Original signature : <code>char isP1extra(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4419</i>
	 */
	public static native byte isP1extra(lprec lp);
	/**
	 * Original signature : <code>double get_refactfrequency(lprec*, unsigned final char)</code><br>
	 * <i>native declaration : lp_lib.h:4421</i>
	 */
	public static native double get_refactfrequency(lprec lp, byte char1);
	/**
	 * Original signature : <code>int findBasicFixedvar(lprec*, int, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4423</i>
	 */
	public static native int findBasicFixedvar(lprec lp, int afternr, byte slacksonly);
	/**
	 * Original signature : <code>char isBasisVarFeasible(lprec*, double, int)</code><br>
	 * <i>native declaration : lp_lib.h:4425</i>
	 */
	public static native byte isBasisVarFeasible(lprec lp, double tol, int basis_row);
	/**
	 * Original signature : <code>char isPrimalFeasible(lprec*, double, int[], double*)</code><br>
	 * <i>native declaration : lp_lib.h:4427</i><br>
	 * @deprecated use the safer methods {@link #isPrimalFeasible(lpsolvelib.lprec, double, java.nio.IntBuffer, java.nio.DoubleBuffer)} and {@link #isPrimalFeasible(lpsolvelib.lprec, double, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native byte isPrimalFeasible(lprec lp, double tol, IntByReference infeasibles, DoubleByReference feasibilitygap);
	/**
	 * Original signature : <code>char isPrimalFeasible(lprec*, double, int[], double*)</code><br>
	 * <i>native declaration : lp_lib.h:4427</i>
	 */
	public static native byte isPrimalFeasible(lprec lp, double tol, IntBuffer infeasibles, DoubleBuffer feasibilitygap);
	/**
	 * Original signature : <code>char isDualFeasible(lprec*, double, int*, int[], double*)</code><br>
	 * <i>native declaration : lp_lib.h:4429</i><br>
	 * @deprecated use the safer methods {@link #isDualFeasible(lpsolvelib.lprec, double, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.DoubleBuffer)} and {@link #isDualFeasible(lpsolvelib.lprec, double, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native byte isDualFeasible(lprec lp, double tol, IntByReference boundflips, IntByReference infeasibles, DoubleByReference feasibilitygap);
	/**
	 * Original signature : <code>char isDualFeasible(lprec*, double, int*, int[], double*)</code><br>
	 * <i>native declaration : lp_lib.h:4429</i>
	 */
	public static native byte isDualFeasible(lprec lp, double tol, IntBuffer boundflips, IntBuffer infeasibles, DoubleBuffer feasibilitygap);
	/**
	 * Main simplex driver routines<br>
	 * Original signature : <code>int preprocess(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4434</i>
	 */
	public static native int preprocess(lprec lp);
	/**
	 * Original signature : <code>void postprocess(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4436</i>
	 */
	public static native void postprocess(lprec lp);
	/**
	 * Original signature : <code>char performiteration(lprec*, int, int, double, unsigned char, unsigned char, double*, int*, double*, int*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4438</i><br>
	 * @deprecated use the safer methods {@link #performiteration(lpsolvelib.lprec, int, int, double, byte, byte, java.nio.DoubleBuffer, java.nio.IntBuffer, java.nio.DoubleBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #performiteration(lpsolvelib.lprec, int, int, double, byte, byte, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native byte performiteration(lprec lp, int rownr, int varin, double theta, byte primal, byte allowminit, DoubleByReference prow, IntByReference nzprow, DoubleByReference pcol, IntByReference nzpcol, IntByReference boundswaps);
	/**
	 * Original signature : <code>char performiteration(lprec*, int, int, double, unsigned char, unsigned char, double*, int*, double*, int*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4438</i>
	 */
	public static native byte performiteration(lprec lp, int rownr, int varin, double theta, byte primal, byte allowminit, DoubleBuffer prow, IntBuffer nzprow, DoubleBuffer pcol, IntBuffer nzpcol, IntBuffer boundswaps);
	/**
	 * Original signature : <code>void transfer_solution(lprec*, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4442</i>
	 */
	public static native void transfer_solution(lprec lp, byte dofinal);
	/**
	 * Scaling utilities<br>
	 * Original signature : <code>double scaled_floor(lprec*, int, double, double)</code><br>
	 * <i>native declaration : lp_lib.h:4447</i>
	 */
	public static native double scaled_floor(lprec lp, int colnr, double value, double epsscale);
	/**
	 * Original signature : <code>double scaled_ceil(lprec*, int, double, double)</code><br>
	 * <i>native declaration : lp_lib.h:4449</i>
	 */
	public static native double scaled_ceil(lprec lp, int colnr, double value, double epsscale);
	/**
	 * Variable mapping utility routines<br>
	 * Original signature : <code>void varmap_lock(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4454</i>
	 */
	public static native void varmap_lock(lprec lp);
	/**
	 * Original signature : <code>void varmap_clear(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4456</i>
	 */
	public static native void varmap_clear(lprec lp);
	/**
	 * Original signature : <code>char varmap_canunlock(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4458</i>
	 */
	public static native byte varmap_canunlock(lprec lp);
	/**
	 * Original signature : <code>void varmap_addconstraint(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4460</i>
	 */
	public static native void varmap_addconstraint(lprec lp);
	/**
	 * Original signature : <code>void varmap_addcolumn(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4462</i>
	 */
	public static native void varmap_addcolumn(lprec lp);
	/**
	 * Original signature : <code>void varmap_delete(lprec*, int, int, LLrec*)</code><br>
	 * <i>native declaration : lp_lib.h:4464</i>
	 */
	public static native void varmap_delete(lprec lp, int base, int delta, LLrec varmap);
	/**
	 * Original signature : <code>void varmap_compact(lprec*, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:4466</i>
	 */
	public static native void varmap_compact(lprec lp, int prev_rows, int prev_cols);
	/**
	 * Original signature : <code>char varmap_validate(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4468</i>
	 */
	public static native byte varmap_validate(lprec lp, int varno);
	/**
	 * STATIC MYBOOL del_varnameex(lprec *lp, hashelem **namelist, hashtable *ht, int varnr, LLrec *varmap);<br>
	 * Original signature : <code>char del_varnameex(lprec*, hashelem**, int, hashtable*, int, LLrec*)</code><br>
	 * <i>native declaration : lp_lib.h:4473</i><br>
	 * @deprecated use the safer method {@link #del_varnameex(lpsolvelib.lprec, lpsolvehash.hashelem.ByReference[], int, lpsolvehash.hashtable, int, lpsolveutils.LLrec)} instead
	 */
	@Deprecated 
	public static native byte del_varnameex(lprec lp, PointerByReference namelist, int items, hashtable ht, int varnr, LLrec varmap);
	/**
	 * STATIC MYBOOL del_varnameex(lprec *lp, hashelem **namelist, hashtable *ht, int varnr, LLrec *varmap);<br>
	 * Original signature : <code>char del_varnameex(lprec*, hashelem**, int, hashtable*, int, LLrec*)</code><br>
	 * <i>native declaration : lp_lib.h:4473</i>
	 */
	public static native byte del_varnameex(lprec lp, lpsolvehash.hashelem.ByReference namelist[], int items, hashtable ht, int varnr, LLrec varmap);
	/**
	 * Pseudo-cost routines (internal)<br>
	 * Original signature : <code>BBPSrec* init_pseudocost(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4478</i>
	 */
	public static native BBPSrec init_pseudocost(lprec lp, int pseudotype);
	/**
	 * Original signature : <code>void free_pseudocost(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4480</i>
	 */
	public static native void free_pseudocost(lprec lp);
	/**
	 * Original signature : <code>double get_pseudorange(BBPSrec*, int, int)</code><br>
	 * <i>native declaration : lp_lib.h:4482</i>
	 */
	public static native double get_pseudorange(BBPSrec pc, int mipvar, int varcode);
	/**
	 * Original signature : <code>void update_pseudocost(BBPSrec*, int, int, unsigned char, double)</code><br>
	 * <i>native declaration : lp_lib.h:4484</i>
	 */
	public static native void update_pseudocost(BBPSrec pc, int mipvar, int varcode, byte capupper, double varsol);
	/**
	 * Original signature : <code>double get_pseudobranchcost(BBPSrec*, int, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4486</i>
	 */
	public static native double get_pseudobranchcost(BBPSrec pc, int mipvar, byte dofloor);
	/**
	 * Original signature : <code>double get_pseudonodecost(BBPSrec*, int, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:4488</i>
	 */
	public static native double get_pseudonodecost(BBPSrec pc, int mipvar, int vartype, double varsol);
	/**
	 * Matrix access and equation solving routines<br>
	 * Original signature : <code>void set_OF_override(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4493</i><br>
	 * @deprecated use the safer methods {@link #set_OF_override(lpsolvelib.lprec, java.nio.DoubleBuffer)} and {@link #set_OF_override(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native void set_OF_override(lprec lp, DoubleByReference ofVector);
	/**
	 * Matrix access and equation solving routines<br>
	 * Original signature : <code>void set_OF_override(lprec*, double*)</code><br>
	 * <i>native declaration : lp_lib.h:4493</i>
	 */
	public static native void set_OF_override(lprec lp, DoubleBuffer ofVector);
	/**
	 * Original signature : <code>void set_OF_p1extra(lprec*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4495</i>
	 */
	public static native void set_OF_p1extra(lprec lp, double p1extra);
	/**
	 * Original signature : <code>void unset_OF_p1extra(lprec*)</code><br>
	 * <i>native declaration : lp_lib.h:4497</i>
	 */
	public static native void unset_OF_p1extra(lprec lp);
	/**
	 * Original signature : <code>char modifyOF1(lprec*, int, double*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4499</i><br>
	 * @deprecated use the safer methods {@link #modifyOF1(lpsolvelib.lprec, int, java.nio.DoubleBuffer, double)} and {@link #modifyOF1(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, double)} instead
	 */
	@Deprecated 
	public static native byte modifyOF1(lprec lp, int index, DoubleByReference ofValue, double mult);
	/**
	 * Original signature : <code>char modifyOF1(lprec*, int, double*, double)</code><br>
	 * <i>native declaration : lp_lib.h:4499</i>
	 */
	public static native byte modifyOF1(lprec lp, int index, DoubleBuffer ofValue, double mult);
	/**
	 * Original signature : <code>WINAPI get_OF_active(lprec*, int, double)</code><br>
	 * <i>native declaration : lp_lib.h:4501</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_OF_active(lprec lp, int varnr, double mult);
	/**
	 * Original signature : <code>char is_OF_nz(lprec*, int)</code><br>
	 * <i>native declaration : lp_lib.h:4503</i>
	 */
	public static native byte is_OF_nz(lprec lp, int colnr);
	/**
	 * Original signature : <code>int get_basisOF(lprec*, int[], double[], int[])</code><br>
	 * <i>native declaration : lp_lib.h:4505</i><br>
	 * @deprecated use the safer methods {@link #get_basisOF(lpsolvelib.lprec, java.nio.IntBuffer, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #get_basisOF(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native int get_basisOF(lprec lp, IntByReference coltarget, DoubleByReference crow, IntByReference colno);
	/**
	 * Original signature : <code>int get_basisOF(lprec*, int[], double[], int[])</code><br>
	 * <i>native declaration : lp_lib.h:4505</i>
	 */
	public static native int get_basisOF(lprec lp, IntBuffer coltarget, DoubleBuffer crow, IntBuffer colno);
	/**
	 * Original signature : <code>WINAPI get_basiscolumn(lprec*, int, int[], double[])</code><br>
	 * <i>native declaration : lp_lib.h:4507</i><br>
	 * @deprecated use the safer methods {@link #get_basiscolumn(lpsolvelib.lprec, int, java.nio.IntBuffer, java.nio.DoubleBuffer)} and {@link #get_basiscolumn(lpsolvelib.lprec, int, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI get_basiscolumn(lprec lp, int j, IntByReference rn, DoubleByReference bj);
	/**
	 * Original signature : <code>WINAPI get_basiscolumn(lprec*, int, int[], double[])</code><br>
	 * <i>native declaration : lp_lib.h:4507</i>
	 */
	public static native LpSolveLibLibrary.WINAPI get_basiscolumn(lprec lp, int j, IntBuffer rn, DoubleBuffer bj);
	/**
	 * Original signature : <code>WINAPI obtain_column(lprec*, int, double*, int*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4509</i><br>
	 * @deprecated use the safer methods {@link #obtain_column(lpsolvelib.lprec, int, java.nio.DoubleBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #obtain_column(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native LpSolveLibLibrary.WINAPI obtain_column(lprec lp, int varin, DoubleByReference pcol, IntByReference nzlist, IntByReference maxabs);
	/**
	 * Original signature : <code>WINAPI obtain_column(lprec*, int, double*, int*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4509</i>
	 */
	public static native LpSolveLibLibrary.WINAPI obtain_column(lprec lp, int varin, DoubleBuffer pcol, IntBuffer nzlist, IntBuffer maxabs);
	/**
	 * Original signature : <code>int compute_theta(lprec*, int, double*, int, double, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4511</i><br>
	 * @deprecated use the safer methods {@link #compute_theta(lpsolvelib.lprec, int, java.nio.DoubleBuffer, int, double, byte)} and {@link #compute_theta(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, int, double, byte)} instead
	 */
	@Deprecated 
	public static native int compute_theta(lprec lp, int rownr, DoubleByReference theta, int isupbound, double HarrisScalar, byte primal);
	/**
	 * Original signature : <code>int compute_theta(lprec*, int, double*, int, double, unsigned char)</code><br>
	 * <i>native declaration : lp_lib.h:4511</i>
	 */
	public static native int compute_theta(lprec lp, int rownr, DoubleBuffer theta, int isupbound, double HarrisScalar, byte primal);
	/**
	 * Pivot utility routines<br>
	 * Original signature : <code>int findBasisPos(lprec*, int, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4516</i><br>
	 * @deprecated use the safer methods {@link #findBasisPos(lpsolvelib.lprec, int, java.nio.IntBuffer)} and {@link #findBasisPos(lpsolvelib.lprec, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native int findBasisPos(lprec lp, int notint, IntByReference var_basic);
	/**
	 * Pivot utility routines<br>
	 * Original signature : <code>int findBasisPos(lprec*, int, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4516</i>
	 */
	public static native int findBasisPos(lprec lp, int notint, IntBuffer var_basic);
	/**
	 * Original signature : <code>char check_degeneracy(lprec*, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4518</i><br>
	 * @deprecated use the safer methods {@link #check_degeneracy(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #check_degeneracy(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native byte check_degeneracy(lprec lp, DoubleByReference pcol, IntByReference degencount);
	/**
	 * Original signature : <code>char check_degeneracy(lprec*, double*, int*)</code><br>
	 * <i>native declaration : lp_lib.h:4518</i>
	 */
	public static native byte check_degeneracy(lprec lp, DoubleBuffer pcol, IntBuffer degencount);
	public static class get_Nrows_func extends PointerType {
		public get_Nrows_func(Pointer address) {
			super(address);
		}
		public get_Nrows_func() {
			super();
		}
	};
	public static class get_rh_range_func extends PointerType {
		public get_rh_range_func(Pointer address) {
			super(address);
		}
		public get_rh_range_func() {
			super();
		}
	};
	public static class read_MPS_func extends PointerType {
		public read_MPS_func(Pointer address) {
			super(address);
		}
		public read_MPS_func() {
			super();
		}
	};
	public static class get_epsperturb_func extends PointerType {
		public get_epsperturb_func(Pointer address) {
			super(address);
		}
		public get_epsperturb_func() {
			super();
		}
	};
	public static class set_bb_floorfirst_func extends PointerType {
		public set_bb_floorfirst_func(Pointer address) {
			super(address);
		}
		public set_bb_floorfirst_func() {
			super();
		}
	};
	public static class get_var_branch_func extends PointerType {
		public get_var_branch_func(Pointer address) {
			super(address);
		}
		public get_var_branch_func() {
			super();
		}
	};
	public static class set_basiscrash_func extends PointerType {
		public set_basiscrash_func(Pointer address) {
			super(address);
		}
		public set_basiscrash_func() {
			super();
		}
	};
	public static class get_lambda_func extends PointerType {
		public get_lambda_func(Pointer address) {
			super(address);
		}
		public get_lambda_func() {
			super();
		}
	};
	public static class set_trace_func extends PointerType {
		public set_trace_func(Pointer address) {
			super(address);
		}
		public set_trace_func() {
			super();
		}
	};
	public static class is_int_func extends PointerType {
		public is_int_func(Pointer address) {
			super(address);
		}
		public is_int_func() {
			super();
		}
	};
	public static class reset_basis_func extends PointerType {
		public reset_basis_func(Pointer address) {
			super(address);
		}
		public reset_basis_func() {
			super();
		}
	};
	public static class get_rowex_func extends PointerType {
		public get_rowex_func(Pointer address) {
			super(address);
		}
		public get_rowex_func() {
			super();
		}
	};
	public static class str_add_constraint_func extends PointerType {
		public str_add_constraint_func(Pointer address) {
			super(address);
		}
		public str_add_constraint_func() {
			super();
		}
	};
	public static class set_upbo_func extends PointerType {
		public set_upbo_func(Pointer address) {
			super(address);
		}
		public set_upbo_func() {
			super();
		}
	};
	public static class add_constraintex_func extends PointerType {
		public add_constraintex_func(Pointer address) {
			super(address);
		}
		public add_constraintex_func() {
			super();
		}
	};
	public static class get_Lrows_func extends PointerType {
		public get_Lrows_func(Pointer address) {
			super(address);
		}
		public get_Lrows_func() {
			super();
		}
	};
	public static class set_simplextype_func extends PointerType {
		public set_simplextype_func(Pointer address) {
			super(address);
		}
		public set_simplextype_func() {
			super();
		}
	};
	public static class default_basis_func extends PointerType {
		public default_basis_func(Pointer address) {
			super(address);
		}
		public default_basis_func() {
			super();
		}
	};
	public static class set_XLI_func extends PointerType {
		public set_XLI_func(Pointer address) {
			super(address);
		}
		public set_XLI_func() {
			super();
		}
	};
	public static class set_break_at_value_func extends PointerType {
		public set_break_at_value_func(Pointer address) {
			super(address);
		}
		public set_break_at_value_func() {
			super();
		}
	};
	public static class set_basis_func extends PointerType {
		public set_basis_func(Pointer address) {
			super(address);
		}
		public set_basis_func() {
			super();
		}
	};
	public static class XLIchar extends PointerType {
		public XLIchar(Pointer address) {
			super(address);
		}
		public XLIchar() {
			super();
		}
	};
	public static class is_piv_rule_func extends PointerType {
		public is_piv_rule_func(Pointer address) {
			super(address);
		}
		public is_piv_rule_func() {
			super();
		}
	};
	public static class userabortfunc extends PointerType {
		public userabortfunc(Pointer address) {
			super(address);
		}
		public userabortfunc() {
			super();
		}
	};
	public static class get_simplextype_func extends PointerType {
		public get_simplextype_func(Pointer address) {
			super(address);
		}
		public get_simplextype_func() {
			super();
		}
	};
	public static class get_constr_value_func extends PointerType {
		public get_constr_value_func(Pointer address) {
			super(address);
		}
		public get_constr_value_func() {
			super();
		}
	};
	public static class delete_lp_func extends PointerType {
		public delete_lp_func(Pointer address) {
			super(address);
		}
		public delete_lp_func() {
			super();
		}
	};
	public static class get_partialprice_func extends PointerType {
		public get_partialprice_func(Pointer address) {
			super(address);
		}
		public get_partialprice_func() {
			super();
		}
	};
	public static class dualize_lp_func extends PointerType {
		public dualize_lp_func(Pointer address) {
			super(address);
		}
		public dualize_lp_func() {
			super();
		}
	};
	public static class print_scales_func extends PointerType {
		public print_scales_func(Pointer address) {
			super(address);
		}
		public print_scales_func() {
			super();
		}
	};
	public static class set_lp_name_func extends PointerType {
		public set_lp_name_func(Pointer address) {
			super(address);
		}
		public set_lp_name_func() {
			super();
		}
	};
	public static class set_sense_func extends PointerType {
		public set_sense_func(Pointer address) {
			super(address);
		}
		public set_sense_func() {
			super();
		}
	};
	public static class write_basis_func extends PointerType {
		public write_basis_func(Pointer address) {
			super(address);
		}
		public write_basis_func() {
			super();
		}
	};
	public static class clear_actionfunc extends PointerType {
		public clear_actionfunc(Pointer address) {
			super(address);
		}
		public clear_actionfunc() {
			super();
		}
	};
	public static class write_XLI_func extends PointerType {
		public write_XLI_func(Pointer address) {
			super(address);
		}
		public write_XLI_func() {
			super();
		}
	};
	public static class getvectorfunc extends PointerType {
		public getvectorfunc(Pointer address) {
			super(address);
		}
		public getvectorfunc() {
			super();
		}
	};
	public static class get_ptr_constraints_func extends PointerType {
		public get_ptr_constraints_func(Pointer address) {
			super(address);
		}
		public get_ptr_constraints_func() {
			super();
		}
	};
	public static class get_epsel_func extends PointerType {
		public get_epsel_func(Pointer address) {
			super(address);
		}
		public get_epsel_func() {
			super();
		}
	};
	public static class set_rowex_func extends PointerType {
		public set_rowex_func(Pointer address) {
			super(address);
		}
		public set_rowex_func() {
			super();
		}
	};
	public static class set_BFP_func extends PointerType {
		public set_BFP_func(Pointer address) {
			super(address);
		}
		public set_BFP_func() {
			super();
		}
	};
	public static class FILE extends PointerType {
		public FILE(Pointer address) {
			super(address);
		}
		public FILE() {
			super();
		}
	};
	public static class get_presolveloops_func extends PointerType {
		public get_presolveloops_func(Pointer address) {
			super(address);
		}
		public get_presolveloops_func() {
			super();
		}
	};
	public static class del_constraint_func extends PointerType {
		public del_constraint_func(Pointer address) {
			super(address);
		}
		public del_constraint_func() {
			super();
		}
	};
	public static class get_status_func extends PointerType {
		public get_status_func(Pointer address) {
			super(address);
		}
		public get_status_func() {
			super();
		}
	};
	public static class get_rh_func extends PointerType {
		public get_rh_func(Pointer address) {
			super(address);
		}
		public get_rh_func() {
			super();
		}
	};
	public static class write_freemps_func extends PointerType {
		public write_freemps_func(Pointer address) {
			super(address);
		}
		public write_freemps_func() {
			super();
		}
	};
	public static class set_verbose_func extends PointerType {
		public set_verbose_func(Pointer address) {
			super(address);
		}
		public set_verbose_func() {
			super();
		}
	};
	public static class get_bb_rule_func extends PointerType {
		public get_bb_rule_func(Pointer address) {
			super(address);
		}
		public get_bb_rule_func() {
			super();
		}
	};
	public static class get_maxpivot_func extends PointerType {
		public get_maxpivot_func(Pointer address) {
			super(address);
		}
		public get_maxpivot_func() {
			super();
		}
	};
	public static class write_params_func extends PointerType {
		public write_params_func(Pointer address) {
			super(address);
		}
		public write_params_func() {
			super();
		}
	};
	public static class print_objective_func extends PointerType {
		public print_objective_func(Pointer address) {
			super(address);
		}
		public print_objective_func() {
			super();
		}
	};
	public static class set_timeout_func extends PointerType {
		public set_timeout_func(Pointer address) {
			super(address);
		}
		public set_timeout_func() {
			super();
		}
	};
	public static class write_MPS_func extends PointerType {
		public write_MPS_func(Pointer address) {
			super(address);
		}
		public write_MPS_func() {
			super();
		}
	};
	public static class is_use_names_func extends PointerType {
		public is_use_names_func(Pointer address) {
			super(address);
		}
		public is_use_names_func() {
			super();
		}
	};
	public static class get_epspivot_func extends PointerType {
		public get_epspivot_func(Pointer address) {
			super(address);
		}
		public get_epspivot_func() {
			super();
		}
	};
	public static class is_trace_func extends PointerType {
		public is_trace_func(Pointer address) {
			super(address);
		}
		public is_trace_func() {
			super();
		}
	};
	public static class put_bb_branchfunc_func extends PointerType {
		public put_bb_branchfunc_func(Pointer address) {
			super(address);
		}
		public put_bb_branchfunc_func() {
			super();
		}
	};
	public static class lphandleint_func extends PointerType {
		public lphandleint_func(Pointer address) {
			super(address);
		}
		public lphandleint_func() {
			super();
		}
	};
	public static class INVrec extends PointerType {
		public INVrec(Pointer address) {
			super(address);
		}
		public INVrec() {
			super();
		}
	};
	public static class set_scaling_func extends PointerType {
		public set_scaling_func(Pointer address) {
			super(address);
		}
		public set_scaling_func() {
			super();
		}
	};
	public static class set_debug_func extends PointerType {
		public set_debug_func(Pointer address) {
			super(address);
		}
		public set_debug_func() {
			super();
		}
	};
	public static class is_negative_func extends PointerType {
		public is_negative_func(Pointer address) {
			super(address);
		}
		public is_negative_func() {
			super();
		}
	};
	public static class is_actionfunc extends PointerType {
		public is_actionfunc(Pointer address) {
			super(address);
		}
		public is_actionfunc() {
			super();
		}
	};
	public static class set_improve_func extends PointerType {
		public set_improve_func(Pointer address) {
			super(address);
		}
		public set_improve_func() {
			super();
		}
	};
	public static class explainfunc extends PointerType {
		public explainfunc(Pointer address) {
			super(address);
		}
		public explainfunc() {
			super();
		}
	};
	public static class is_unbounded_func extends PointerType {
		public is_unbounded_func(Pointer address) {
			super(address);
		}
		public is_unbounded_func() {
			super();
		}
	};
	public static class get_upbo_func extends PointerType {
		public get_upbo_func(Pointer address) {
			super(address);
		}
		public get_upbo_func() {
			super();
		}
	};
	public static class read_LP_func extends PointerType {
		public read_LP_func(Pointer address) {
			super(address);
		}
		public read_LP_func() {
			super();
		}
	};
	public static class get_infinite_func extends PointerType {
		public get_infinite_func(Pointer address) {
			super(address);
		}
		public get_infinite_func() {
			super();
		}
	};
	public static class set_pivoting_func extends PointerType {
		public set_pivoting_func(Pointer address) {
			super(address);
		}
		public set_pivoting_func() {
			super();
		}
	};
	public static class get_col_name_func extends PointerType {
		public get_col_name_func(Pointer address) {
			super(address);
		}
		public get_col_name_func() {
			super();
		}
	};
	public static class read_basis_func extends PointerType {
		public read_basis_func(Pointer address) {
			super(address);
		}
		public read_basis_func() {
			super();
		}
	};
	public static class is_debug_func extends PointerType {
		public is_debug_func(Pointer address) {
			super(address);
		}
		public is_debug_func() {
			super();
		}
	};
	public static class get_orig_index_func extends PointerType {
		public get_orig_index_func(Pointer address) {
			super(address);
		}
		public get_orig_index_func() {
			super();
		}
	};
	public static class set_epsint_func extends PointerType {
		public set_epsint_func(Pointer address) {
			super(address);
		}
		public set_epsint_func() {
			super();
		}
	};
	public static class is_semicont_func extends PointerType {
		public is_semicont_func(Pointer address) {
			super(address);
		}
		public is_semicont_func() {
			super();
		}
	};
	public static class get_var_dualresult_func extends PointerType {
		public get_var_dualresult_func(Pointer address) {
			super(address);
		}
		public get_var_dualresult_func() {
			super();
		}
	};
	public static class get_origcol_name_func extends PointerType {
		public get_origcol_name_func(Pointer address) {
			super(address);
		}
		public get_origcol_name_func() {
			super();
		}
	};
	public static class getMDOfunc extends PointerType {
		public getMDOfunc(Pointer address) {
			super(address);
		}
		public getMDOfunc() {
			super();
		}
	};
	public static class str_set_obj_fn_func extends PointerType {
		public str_set_obj_fn_func(Pointer address) {
			super(address);
		}
		public str_set_obj_fn_func() {
			super();
		}
	};
	public static class set_mat_func extends PointerType {
		public set_mat_func(Pointer address) {
			super(address);
		}
		public set_mat_func() {
			super();
		}
	};
	public static class get_nz_func extends PointerType {
		public get_nz_func(Pointer address) {
			super(address);
		}
		public get_nz_func() {
			super();
		}
	};
	public static class print_constraints_func extends PointerType {
		public print_constraints_func(Pointer address) {
			super(address);
		}
		public print_constraints_func() {
			super();
		}
	};
	public static class get_dual_solution_func extends PointerType {
		public get_dual_solution_func(Pointer address) {
			super(address);
		}
		public get_dual_solution_func() {
			super();
		}
	};
	public static class set_binary_func extends PointerType {
		public set_binary_func(Pointer address) {
			super(address);
		}
		public set_binary_func() {
			super();
		}
	};
	public static class read_params_func extends PointerType {
		public read_params_func(Pointer address) {
			super(address);
		}
		public read_params_func() {
			super();
		}
	};
	public static class set_actionfunc extends PointerType {
		public set_actionfunc(Pointer address) {
			super(address);
		}
		public set_actionfunc() {
			super();
		}
	};
	public static class get_Norig_columns_func extends PointerType {
		public get_Norig_columns_func(Pointer address) {
			super(address);
		}
		public get_Norig_columns_func() {
			super();
		}
	};
	public static class get_constraints_func extends PointerType {
		public get_constraints_func(Pointer address) {
			super(address);
		}
		public get_constraints_func() {
			super();
		}
	};
	public static class set_bounds_tighter_func extends PointerType {
		public set_bounds_tighter_func(Pointer address) {
			super(address);
		}
		public set_bounds_tighter_func() {
			super();
		}
	};
	public static class get_variables_func extends PointerType {
		public get_variables_func(Pointer address) {
			super(address);
		}
		public get_variables_func() {
			super();
		}
	};
	public static class is_obj_in_basis_func extends PointerType {
		public is_obj_in_basis_func(Pointer address) {
			super(address);
		}
		public is_obj_in_basis_func() {
			super();
		}
	};
	public static class write_LP_func extends PointerType {
		public write_LP_func(Pointer address) {
			super(address);
		}
		public write_LP_func() {
			super();
		}
	};
	public static class BFPchar extends PointerType {
		public BFPchar(Pointer address) {
			super(address);
		}
		public BFPchar() {
			super();
		}
	};
	public static class get_mip_gap_func extends PointerType {
		public get_mip_gap_func(Pointer address) {
			super(address);
		}
		public get_mip_gap_func() {
			super();
		}
	};
	public static class unscale_func extends PointerType {
		public unscale_func(Pointer address) {
			super(address);
		}
		public unscale_func() {
			super();
		}
	};
	public static class str_add_lag_con_func extends PointerType {
		public str_add_lag_con_func(Pointer address) {
			super(address);
		}
		public str_add_lag_con_func() {
			super();
		}
	};
	public static class set_scalelimit_func extends PointerType {
		public set_scalelimit_func(Pointer address) {
			super(address);
		}
		public set_scalelimit_func() {
			super();
		}
	};
	public static class put_abortfunc_func extends PointerType {
		public put_abortfunc_func(Pointer address) {
			super(address);
		}
		public put_abortfunc_func() {
			super();
		}
	};
	public static class get_sensitivity_rhs_func extends PointerType {
		public get_sensitivity_rhs_func(Pointer address) {
			super(address);
		}
		public get_sensitivity_rhs_func() {
			super();
		}
	};
	public static class print_lp_func extends PointerType {
		public print_lp_func(Pointer address) {
			super(address);
		}
		public print_lp_func() {
			super();
		}
	};
	public static class lphandle_intfunc extends PointerType {
		public lphandle_intfunc(Pointer address) {
			super(address);
		}
		public lphandle_intfunc() {
			super();
		}
	};
	public static class is_scaletype_func extends PointerType {
		public is_scaletype_func(Pointer address) {
			super(address);
		}
		public is_scaletype_func() {
			super();
		}
	};
	public static class set_row_name_func extends PointerType {
		public set_row_name_func(Pointer address) {
			super(address);
		}
		public set_row_name_func() {
			super();
		}
	};
	public static class is_infinite_func extends PointerType {
		public is_infinite_func(Pointer address) {
			super(address);
		}
		public is_infinite_func() {
			super();
		}
	};
	public static class set_epsperturb_func extends PointerType {
		public set_epsperturb_func(Pointer address) {
			super(address);
		}
		public set_epsperturb_func() {
			super();
		}
	};
	public static class print_str_func extends PointerType {
		public print_str_func(Pointer address) {
			super(address);
		}
		public print_str_func() {
			super();
		}
	};
	public static class set_columnex_func extends PointerType {
		public set_columnex_func(Pointer address) {
			super(address);
		}
		public set_columnex_func() {
			super();
		}
	};
	public static class get_presolve_func extends PointerType {
		public get_presolve_func(Pointer address) {
			super(address);
		}
		public get_presolve_func() {
			super();
		}
	};
	public static class get_mat_byindex_func extends PointerType {
		public get_mat_byindex_func(Pointer address) {
			super(address);
		}
		public get_mat_byindex_func() {
			super();
		}
	};
	public static class lphandlestr_func extends PointerType {
		public lphandlestr_func(Pointer address) {
			super(address);
		}
		public lphandlestr_func() {
			super();
		}
	};
	public static class set_obj_bound_func extends PointerType {
		public set_obj_bound_func(Pointer address) {
			super(address);
		}
		public set_obj_bound_func() {
			super();
		}
	};
	public static class set_obj_in_basis_func extends PointerType {
		public set_obj_in_basis_func(Pointer address) {
			super(address);
		}
		public set_obj_in_basis_func() {
			super();
		}
	};
	public static class set_anti_degen_func extends PointerType {
		public set_anti_degen_func(Pointer address) {
			super(address);
		}
		public set_anti_degen_func() {
			super();
		}
	};
	public static class get_Ncolumns_func extends PointerType {
		public get_Ncolumns_func(Pointer address) {
			super(address);
		}
		public get_Ncolumns_func() {
			super();
		}
	};
	public static class is_scalemode_func extends PointerType {
		public is_scalemode_func(Pointer address) {
			super(address);
		}
		public is_scalemode_func() {
			super();
		}
	};
	public static class get_solutioncount_func extends PointerType {
		public get_solutioncount_func(Pointer address) {
			super(address);
		}
		public get_solutioncount_func() {
			super();
		}
	};
	public static class set_semicont_func extends PointerType {
		public set_semicont_func(Pointer address) {
			super(address);
		}
		public set_semicont_func() {
			super();
		}
	};
	public static class get_multiprice_func extends PointerType {
		public get_multiprice_func(Pointer address) {
			super(address);
		}
		public get_multiprice_func() {
			super();
		}
	};
	public static class get_columnex_func extends PointerType {
		public get_columnex_func(Pointer address) {
			super(address);
		}
		public get_columnex_func() {
			super();
		}
	};
	public static class column_in_lp_func extends PointerType {
		public column_in_lp_func(Pointer address) {
			super(address);
		}
		public column_in_lp_func() {
			super();
		}
	};
	public static class time_elapsed_func extends PointerType {
		public time_elapsed_func(Pointer address) {
			super(address);
		}
		public time_elapsed_func() {
			super();
		}
	};
	public static class set_print_sol_func extends PointerType {
		public set_print_sol_func(Pointer address) {
			super(address);
		}
		public set_print_sol_func() {
			super();
		}
	};
	public static class get_verbose_func extends PointerType {
		public get_verbose_func(Pointer address) {
			super(address);
		}
		public get_verbose_func() {
			super();
		}
	};
	public static class get_break_at_value_func extends PointerType {
		public get_break_at_value_func(Pointer address) {
			super(address);
		}
		public get_break_at_value_func() {
			super();
		}
	};
	public static class set_row_func extends PointerType {
		public set_row_func(Pointer address) {
			super(address);
		}
		public set_row_func() {
			super();
		}
	};
	public static class invertfunc extends PointerType {
		public invertfunc(Pointer address) {
			super(address);
		}
		public invertfunc() {
			super();
		}
	};
	public static class set_bounds_func extends PointerType {
		public set_bounds_func(Pointer address) {
			super(address);
		}
		public set_bounds_func() {
			super();
		}
	};
	public static class set_constr_type_func extends PointerType {
		public set_constr_type_func(Pointer address) {
			super(address);
		}
		public set_constr_type_func() {
			super();
		}
	};
	public static class set_col_name_func extends PointerType {
		public set_col_name_func(Pointer address) {
			super(address);
		}
		public set_col_name_func() {
			super();
		}
	};
	public static class get_ptr_dual_solution_func extends PointerType {
		public get_ptr_dual_solution_func(Pointer address) {
			super(address);
		}
		public get_ptr_dual_solution_func() {
			super();
		}
	};
	public static class read_XLI_func extends PointerType {
		public read_XLI_func(Pointer address) {
			super(address);
		}
		public read_XLI_func() {
			super();
		}
	};
	public static class set_epsb_func extends PointerType {
		public set_epsb_func(Pointer address) {
			super(address);
		}
		public set_epsb_func() {
			super();
		}
	};
	public static class get_OF_activefunc extends PointerType {
		public get_OF_activefunc(Pointer address) {
			super(address);
		}
		public get_OF_activefunc() {
			super();
		}
	};
	public static class set_solutionlimit_func extends PointerType {
		public set_solutionlimit_func(Pointer address) {
			super(address);
		}
		public set_solutionlimit_func() {
			super();
		}
	};
	public static class get_obj_bound_func extends PointerType {
		public get_obj_bound_func(Pointer address) {
			super(address);
		}
		public get_obj_bound_func() {
			super();
		}
	};
	public static class set_rh_func extends PointerType {
		public set_rh_func(Pointer address) {
			super(address);
		}
		public set_rh_func() {
			super();
		}
	};
	public static class copy_lp_func extends PointerType {
		public copy_lp_func(Pointer address) {
			super(address);
		}
		public copy_lp_func() {
			super();
		}
	};
	public static class set_column_func extends PointerType {
		public set_column_func(Pointer address) {
			super(address);
		}
		public set_column_func() {
			super();
		}
	};
	public static class set_add_rowmode_func extends PointerType {
		public set_add_rowmode_func(Pointer address) {
			super(address);
		}
		public set_add_rowmode_func() {
			super();
		}
	};
	public static class solve_func extends PointerType {
		public solve_func(Pointer address) {
			super(address);
		}
		public solve_func() {
			super();
		}
	};
	public static class get_var_primalresult_func extends PointerType {
		public get_var_primalresult_func(Pointer address) {
			super(address);
		}
		public get_var_primalresult_func() {
			super();
		}
	};
	public static class get_ptr_primal_solution_func extends PointerType {
		public get_ptr_primal_solution_func(Pointer address) {
			super(address);
		}
		public get_ptr_primal_solution_func() {
			super();
		}
	};
	public static class set_lowbo_func extends PointerType {
		public set_lowbo_func(Pointer address) {
			super(address);
		}
		public set_lowbo_func() {
			super();
		}
	};
	public static class str_add_column_func extends PointerType {
		public str_add_column_func(Pointer address) {
			super(address);
		}
		public str_add_column_func() {
			super();
		}
	};
	public static class get_bb_floorfirst_func extends PointerType {
		public get_bb_floorfirst_func(Pointer address) {
			super(address);
		}
		public get_bb_floorfirst_func() {
			super();
		}
	};
	public static class is_SOS_var_func extends PointerType {
		public is_SOS_var_func(Pointer address) {
			super(address);
		}
		public is_SOS_var_func() {
			super();
		}
	};
	public static class get_lp_index_func extends PointerType {
		public get_lp_index_func(Pointer address) {
			super(address);
		}
		public get_lp_index_func() {
			super();
		}
	};
	public static class set_lag_trace_func extends PointerType {
		public set_lag_trace_func(Pointer address) {
			super(address);
		}
		public set_lag_trace_func() {
			super();
		}
	};
	public static class get_objective_func extends PointerType {
		public get_objective_func(Pointer address) {
			super(address);
		}
		public get_objective_func() {
			super();
		}
	};
	public static class str_set_rh_vec_func extends PointerType {
		public str_set_rh_vec_func(Pointer address) {
			super(address);
		}
		public str_set_rh_vec_func() {
			super();
		}
	};
	public static class get_ptr_sensitivity_rhs_func extends PointerType {
		public get_ptr_sensitivity_rhs_func(Pointer address) {
			super(address);
		}
		public get_ptr_sensitivity_rhs_func() {
			super();
		}
	};
	public static class get_origrow_name_func extends PointerType {
		public get_origrow_name_func(Pointer address) {
			super(address);
		}
		public get_origrow_name_func() {
			super();
		}
	};
	public static class read_modeldata_func extends PointerType {
		public read_modeldata_func(Pointer address) {
			super(address);
		}
		public read_modeldata_func() {
			super();
		}
	};
	public static class set_obj_fn_func extends PointerType {
		public set_obj_fn_func(Pointer address) {
			super(address);
		}
		public set_obj_fn_func() {
			super();
		}
	};
	public static class get_sensitivity_obj_func extends PointerType {
		public get_sensitivity_obj_func(Pointer address) {
			super(address);
		}
		public get_sensitivity_obj_func() {
			super();
		}
	};
	public static class is_break_at_first_func extends PointerType {
		public is_break_at_first_func(Pointer address) {
			super(address);
		}
		public is_break_at_first_func() {
			super();
		}
	};
	public static class set_epspivot_func extends PointerType {
		public set_epspivot_func(Pointer address) {
			super(address);
		}
		public set_epspivot_func() {
			super();
		}
	};
	public static class getpackedfunc extends PointerType {
		public getpackedfunc(Pointer address) {
			super(address);
		}
		public getpackedfunc() {
			super();
		}
	};
	public static class set_rh_range_func extends PointerType {
		public set_rh_range_func(Pointer address) {
			super(address);
		}
		public set_rh_range_func() {
			super();
		}
	};
	public static class get_row_func extends PointerType {
		public get_row_func(Pointer address) {
			super(address);
		}
		public get_row_func() {
			super();
		}
	};
	public static class get_basis_func extends PointerType {
		public get_basis_func(Pointer address) {
			super(address);
		}
		public get_basis_func() {
			super();
		}
	};
	public static class print_solution_func extends PointerType {
		public print_solution_func(Pointer address) {
			super(address);
		}
		public print_solution_func() {
			super();
		}
	};
	public static class set_multiprice_func extends PointerType {
		public set_multiprice_func(Pointer address) {
			super(address);
		}
		public set_multiprice_func() {
			super();
		}
	};
	public static class is_nativeXLI_func extends PointerType {
		public is_nativeXLI_func(Pointer address) {
			super(address);
		}
		public is_nativeXLI_func() {
			super();
		}
	};
	public static class set_maxpivot_func extends PointerType {
		public set_maxpivot_func(Pointer address) {
			super(address);
		}
		public set_maxpivot_func() {
			super();
		}
	};
	public static class add_constraint_func extends PointerType {
		public add_constraint_func(Pointer address) {
			super(address);
		}
		public add_constraint_func() {
			super();
		}
	};
	public static class set_partialprice_func extends PointerType {
		public set_partialprice_func(Pointer address) {
			super(address);
		}
		public set_partialprice_func() {
			super();
		}
	};
	public static class put_msgfunc_func extends PointerType {
		public put_msgfunc_func(Pointer address) {
			super(address);
		}
		public put_msgfunc_func() {
			super();
		}
	};
	public static class lphandleint_intfunc extends PointerType {
		public lphandleint_intfunc(Pointer address) {
			super(address);
		}
		public lphandleint_intfunc() {
			super();
		}
	};
	public static class get_ptr_lambda_func extends PointerType {
		public get_ptr_lambda_func(Pointer address) {
			super(address);
		}
		public get_ptr_lambda_func() {
			super();
		}
	};
	public static class get_pseudocosts_func extends PointerType {
		public get_pseudocosts_func(Pointer address) {
			super(address);
		}
		public get_pseudocosts_func() {
			super();
		}
	};
	public static class get_lp_name_func extends PointerType {
		public get_lp_name_func(Pointer address) {
			super(address);
		}
		public get_lp_name_func() {
			super();
		}
	};
	public static class add_SOS_func extends PointerType {
		public add_SOS_func(Pointer address) {
			super(address);
		}
		public add_SOS_func() {
			super();
		}
	};
	public static class is_maxim_func extends PointerType {
		public is_maxim_func(Pointer address) {
			super(address);
		}
		public is_maxim_func() {
			super();
		}
	};
	public static class is_feasible_func extends PointerType {
		public is_feasible_func(Pointer address) {
			super(address);
		}
		public is_feasible_func() {
			super();
		}
	};
	public static class set_int_func extends PointerType {
		public set_int_func(Pointer address) {
			super(address);
		}
		public set_int_func() {
			super();
		}
	};
	public static class get_statustext_func extends PointerType {
		public get_statustext_func(Pointer address) {
			super(address);
		}
		public get_statustext_func() {
			super();
		}
	};
	public static class get_ptr_sensitivity_obj_func extends PointerType {
		public get_ptr_sensitivity_obj_func(Pointer address) {
			super(address);
		}
		public get_ptr_sensitivity_obj_func() {
			super();
		}
	};
	public static class lp_solve_version_func extends PointerType {
		public lp_solve_version_func(Pointer address) {
			super(address);
		}
		public lp_solve_version_func() {
			super();
		}
	};
	public static class get_epsb_func extends PointerType {
		public get_epsb_func(Pointer address) {
			super(address);
		}
		public get_epsb_func() {
			super();
		}
	};
	public static class set_negrange_func extends PointerType {
		public set_negrange_func(Pointer address) {
			super(address);
		}
		public set_negrange_func() {
			super();
		}
	};
	public static class get_pivoting_func extends PointerType {
		public get_pivoting_func(Pointer address) {
			super(address);
		}
		public get_pivoting_func() {
			super();
		}
	};
	public static class set_bb_rule_func extends PointerType {
		public set_bb_rule_func(Pointer address) {
			super(address);
		}
		public set_bb_rule_func() {
			super();
		}
	};
	public static class put_bb_nodefunc_func extends PointerType {
		public put_bb_nodefunc_func(Pointer address) {
			super(address);
		}
		public put_bb_nodefunc_func() {
			super();
		}
	};
	public static class reset_params_func extends PointerType {
		public reset_params_func(Pointer address) {
			super(address);
		}
		public reset_params_func() {
			super();
		}
	};
	public static class set_epslevel_func extends PointerType {
		public set_epslevel_func(Pointer address) {
			super(address);
		}
		public set_epslevel_func() {
			super();
		}
	};
	public static class get_total_nodes_func extends PointerType {
		public get_total_nodes_func(Pointer address) {
			super(address);
		}
		public get_total_nodes_func() {
			super();
		}
	};
	public static class get_Norig_rows_func extends PointerType {
		public get_Norig_rows_func(Pointer address) {
			super(address);
		}
		public get_Norig_rows_func() {
			super();
		}
	};
	public static class make_lp_func extends PointerType {
		public make_lp_func(Pointer address) {
			super(address);
		}
		public make_lp_func() {
			super();
		}
	};
	public static class get_max_level_func extends PointerType {
		public get_max_level_func(Pointer address) {
			super(address);
		}
		public get_max_level_func() {
			super();
		}
	};
	public static class set_var_branch_func extends PointerType {
		public set_var_branch_func(Pointer address) {
			super(address);
		}
		public set_var_branch_func() {
			super();
		}
	};
	public static class get_ptr_variables_func extends PointerType {
		public get_ptr_variables_func(Pointer address) {
			super(address);
		}
		public get_ptr_variables_func() {
			super();
		}
	};
	public static class set_infinite_func extends PointerType {
		public set_infinite_func(Pointer address) {
			super(address);
		}
		public set_infinite_func() {
			super();
		}
	};
	public static class is_lag_trace_func extends PointerType {
		public is_lag_trace_func(Pointer address) {
			super(address);
		}
		public is_lag_trace_func() {
			super();
		}
	};
	public static class get_ptr_sensitivity_objex_func extends PointerType {
		public get_ptr_sensitivity_objex_func(Pointer address) {
			super(address);
		}
		public get_ptr_sensitivity_objex_func() {
			super();
		}
	};
	public static class get_working_objective_func extends PointerType {
		public get_working_objective_func(Pointer address) {
			super(address);
		}
		public get_working_objective_func() {
			super();
		}
	};
	public static class print_tableau_func extends PointerType {
		public print_tableau_func(Pointer address) {
			super(address);
		}
		public print_tableau_func() {
			super();
		}
	};
	public static class get_improve_func extends PointerType {
		public get_improve_func(Pointer address) {
			super(address);
		}
		public get_improve_func() {
			super();
		}
	};
	public static class set_var_weights_func extends PointerType {
		public set_var_weights_func(Pointer address) {
			super(address);
		}
		public set_var_weights_func() {
			super();
		}
	};
	public static class get_nameindex_func extends PointerType {
		public get_nameindex_func(Pointer address) {
			super(address);
		}
		public get_nameindex_func() {
			super();
		}
	};
	public static class is_integerscaling_func extends PointerType {
		public is_integerscaling_func(Pointer address) {
			super(address);
		}
		public is_integerscaling_func() {
			super();
		}
	};
	public static class get_timeout_func extends PointerType {
		public get_timeout_func(Pointer address) {
			super(address);
		}
		public get_timeout_func() {
			super();
		}
	};
	public static class get_scalelimit_func extends PointerType {
		public get_scalelimit_func(Pointer address) {
			super(address);
		}
		public get_scalelimit_func() {
			super();
		}
	};
	public static class is_add_rowmode_func extends PointerType {
		public is_add_rowmode_func(Pointer address) {
			super(address);
		}
		public is_add_rowmode_func() {
			super();
		}
	};
	public static class add_column_func extends PointerType {
		public add_column_func(Pointer address) {
			super(address);
		}
		public add_column_func() {
			super();
		}
	};
	public static class put_logfunc_func extends PointerType {
		public put_logfunc_func(Pointer address) {
			super(address);
		}
		public put_logfunc_func() {
			super();
		}
	};
	public static class set_outputfile_func extends PointerType {
		public set_outputfile_func(Pointer address) {
			super(address);
		}
		public set_outputfile_func() {
			super();
		}
	};
	public static class set_bb_depthlimit_func extends PointerType {
		public set_bb_depthlimit_func(Pointer address) {
			super(address);
		}
		public set_bb_depthlimit_func() {
			super();
		}
	};
	public static class set_break_at_first_func extends PointerType {
		public set_break_at_first_func(Pointer address) {
			super(address);
		}
		public set_break_at_first_func() {
			super();
		}
	};
	public static class BFPrealp_lp extends PointerType {
		public BFPrealp_lp(Pointer address) {
			super(address);
		}
		public BFPrealp_lp() {
			super();
		}
	};
	public static class get_sensitivity_objex_func extends PointerType {
		public get_sensitivity_objex_func(Pointer address) {
			super(address);
		}
		public get_sensitivity_objex_func() {
			super();
		}
	};
	public static class get_bb_depthlimit_func extends PointerType {
		public get_bb_depthlimit_func(Pointer address) {
			super(address);
		}
		public get_bb_depthlimit_func() {
			super();
		}
	};
	public static class add_columnex_func extends PointerType {
		public add_columnex_func(Pointer address) {
			super(address);
		}
		public add_columnex_func() {
			super();
		}
	};
	public static class print_debugdump_func extends PointerType {
		public print_debugdump_func(Pointer address) {
			super(address);
		}
		public print_debugdump_func() {
			super();
		}
	};
	public static class write_modeldata_func extends PointerType {
		public write_modeldata_func(Pointer address) {
			super(address);
		}
		public write_modeldata_func() {
			super();
		}
	};
	public static class set_basisvar_func extends PointerType {
		public set_basisvar_func(Pointer address) {
			super(address);
		}
		public set_basisvar_func() {
			super();
		}
	};
	public static class set_rh_vec_func extends PointerType {
		public set_rh_vec_func(Pointer address) {
			super(address);
		}
		public set_rh_vec_func() {
			super();
		}
	};
	public static class set_pseudocosts_func extends PointerType {
		public set_pseudocosts_func(Pointer address) {
			super(address);
		}
		public set_pseudocosts_func() {
			super();
		}
	};
	public static class set_outputstream_func extends PointerType {
		public set_outputstream_func(Pointer address) {
			super(address);
		}
		public set_outputstream_func() {
			super();
		}
	};
	public static class get_epsint_func extends PointerType {
		public get_epsint_func(Pointer address) {
			super(address);
		}
		public get_epsint_func() {
			super();
		}
	};
	public static class add_lag_con_func extends PointerType {
		public add_lag_con_func(Pointer address) {
			super(address);
		}
		public add_lag_con_func() {
			super();
		}
	};
	public static class get_negrange_func extends PointerType {
		public get_negrange_func(Pointer address) {
			super(address);
		}
		public get_negrange_func() {
			super();
		}
	};
	public static class has_BFP_func extends PointerType {
		public has_BFP_func(Pointer address) {
			super(address);
		}
		public has_BFP_func() {
			super();
		}
	};
	public static class set_presolve_func extends PointerType {
		public set_presolve_func(Pointer address) {
			super(address);
		}
		public set_presolve_func() {
			super();
		}
	};
	public static class get_total_iter_func extends PointerType {
		public get_total_iter_func(Pointer address) {
			super(address);
		}
		public get_total_iter_func() {
			super();
		}
	};
	public static class get_lowbo_func extends PointerType {
		public get_lowbo_func(Pointer address) {
			super(address);
		}
		public get_lowbo_func() {
			super();
		}
	};
	public static class get_mat_func extends PointerType {
		public get_mat_func(Pointer address) {
			super(address);
		}
		public get_mat_func() {
			super();
		}
	};
	public static class set_obj_func extends PointerType {
		public set_obj_func(Pointer address) {
			super(address);
		}
		public set_obj_func() {
			super();
		}
	};
	public static class free_lp_func extends PointerType {
		public free_lp_func(Pointer address) {
			super(address);
		}
		public free_lp_func() {
			super();
		}
	};
	public static class has_XLI_func extends PointerType {
		public has_XLI_func(Pointer address) {
			super(address);
		}
		public has_XLI_func() {
			super();
		}
	};
	public static class get_row_name_func extends PointerType {
		public get_row_name_func(Pointer address) {
			super(address);
		}
		public get_row_name_func() {
			super();
		}
	};
	public static class get_epsd_func extends PointerType {
		public get_epsd_func(Pointer address) {
			super(address);
		}
		public get_epsd_func() {
			super();
		}
	};
	public static class get_var_priority_func extends PointerType {
		public get_var_priority_func(Pointer address) {
			super(address);
		}
		public get_var_priority_func() {
			super();
		}
	};
	public static class print_duals_func extends PointerType {
		public print_duals_func(Pointer address) {
			super(address);
		}
		public print_duals_func() {
			super();
		}
	};
	public static class set_preferdual_func extends PointerType {
		public set_preferdual_func(Pointer address) {
			super(address);
		}
		public set_preferdual_func() {
			super();
		}
	};
	public static class is_binary_func extends PointerType {
		public is_binary_func(Pointer address) {
			super(address);
		}
		public is_binary_func() {
			super();
		}
	};
	public static class set_maxim_func extends PointerType {
		public set_maxim_func(Pointer address) {
			super(address);
		}
		public set_maxim_func() {
			super();
		}
	};
	public static class resize_lp_func extends PointerType {
		public resize_lp_func(Pointer address) {
			super(address);
		}
		public resize_lp_func() {
			super();
		}
	};
	public static class is_anti_degen_func extends PointerType {
		public is_anti_degen_func(Pointer address) {
			super(address);
		}
		public is_anti_degen_func() {
			super();
		}
	};
	public static class set_use_names_func extends PointerType {
		public set_use_names_func(Pointer address) {
			super(address);
		}
		public set_use_names_func() {
			super();
		}
	};
	public static class get_primal_solution_func extends PointerType {
		public get_primal_solution_func(Pointer address) {
			super(address);
		}
		public get_primal_solution_func() {
			super();
		}
	};
	public static class get_constr_type_func extends PointerType {
		public get_constr_type_func(Pointer address) {
			super(address);
		}
		public get_constr_type_func() {
			super();
		}
	};
	public static class write_lp_func extends PointerType {
		public write_lp_func(Pointer address) {
			super(address);
		}
		public write_lp_func() {
			super();
		}
	};
	public static class set_obj_fnex_func extends PointerType {
		public set_obj_fnex_func(Pointer address) {
			super(address);
		}
		public set_obj_fnex_func() {
			super();
		}
	};
	public static class get_print_sol_func extends PointerType {
		public get_print_sol_func(Pointer address) {
			super(address);
		}
		public get_print_sol_func() {
			super();
		}
	};
	public static class get_scaling_func extends PointerType {
		public get_scaling_func(Pointer address) {
			super(address);
		}
		public get_scaling_func() {
			super();
		}
	};
	public static class get_basiscrash_func extends PointerType {
		public get_basiscrash_func(Pointer address) {
			super(address);
		}
		public get_basiscrash_func() {
			super();
		}
	};
	public static class is_constr_type_func extends PointerType {
		public is_constr_type_func(Pointer address) {
			super(address);
		}
		public is_constr_type_func() {
			super();
		}
	};
	public static class write_mps_func extends PointerType {
		public write_mps_func(Pointer address) {
			super(address);
		}
		public write_mps_func() {
			super();
		}
	};
	public static class set_minim_func extends PointerType {
		public set_minim_func(Pointer address) {
			super(address);
		}
		public set_minim_func() {
			super();
		}
	};
	public static class set_mip_gap_func extends PointerType {
		public set_mip_gap_func(Pointer address) {
			super(address);
		}
		public set_mip_gap_func() {
			super();
		}
	};
	public static class set_unbounded_func extends PointerType {
		public set_unbounded_func(Pointer address) {
			super(address);
		}
		public set_unbounded_func() {
			super();
		}
	};
	public static class get_anti_degen_func extends PointerType {
		public get_anti_degen_func(Pointer address) {
			super(address);
		}
		public get_anti_degen_func() {
			super();
		}
	};
	public static class set_epsd_func extends PointerType {
		public set_epsd_func(Pointer address) {
			super(address);
		}
		public set_epsd_func() {
			super();
		}
	};
	public static class is_presolve_func extends PointerType {
		public is_presolve_func(Pointer address) {
			super(address);
		}
		public is_presolve_func() {
			super();
		}
	};
	public static class write_freeMPS_func extends PointerType {
		public write_freeMPS_func(Pointer address) {
			super(address);
		}
		public write_freeMPS_func() {
			super();
		}
	};
	public static class set_epsel_func extends PointerType {
		public set_epsel_func(Pointer address) {
			super(address);
		}
		public set_epsel_func() {
			super();
		}
	};
	public static class is_nativeBFP_func extends PointerType {
		public is_nativeBFP_func(Pointer address) {
			super(address);
		}
		public is_nativeBFP_func() {
			super();
		}
	};
	public static class is_piv_mode_func extends PointerType {
		public is_piv_mode_func(Pointer address) {
			super(address);
		}
		public is_piv_mode_func() {
			super();
		}
	};
	public static class get_bounds_tighter_func extends PointerType {
		public get_bounds_tighter_func(Pointer address) {
			super(address);
		}
		public get_bounds_tighter_func() {
			super();
		}
	};
	public static class del_column_func extends PointerType {
		public del_column_func(Pointer address) {
			super(address);
		}
		public del_column_func() {
			super();
		}
	};
	public static class get_solutionlimit_func extends PointerType {
		public get_solutionlimit_func(Pointer address) {
			super(address);
		}
		public get_solutionlimit_func() {
			super();
		}
	};
}
