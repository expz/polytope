/*
 * JNAerator configuration for building interface to LpSolve 5.5.2
 *   TARGET:       JNA
 *   ARCHITECTURE: linux_x86
 *   OUTPUT:       Java source
 *
 * WARNING: The include path must be adjusted according to the machine.
 *          Try the path to the includes for your C-compiler. On Ubuntu,
 *          search for headers using:
 *            $ sudo apt-file update; apt-file search <MY_HEADER>.h
 */

// Target for JNA runtime (Other option: BridJ)
-runtime JNA

// Specify the current architecture
// Options:  linux_x64 | linux_x86 | armeabi | sunos_x86 | sunos_sparc | 
//           darwin_universal | win32 | win64
-arch linux_x86

// Output to the current directory
-o .

// Attempt to use javac instead of ecj
-preferJavac

// Reify the pseudo-classes in C 
// someFunct(typedPtr) ==> typedPtr.someFunct()
-reification

// Utilize JNA's faster direct call convention
-direct

// Headers to parse
-library LpSolveHash lp_Hash.h liblpsolve55.so
-library LpSolveLib lp_lib.h liblpsolve55.so
-library LpSolveMatrix lp_matrix.h liblpsolve55.so
-library LpSolveMipbb lp_mipbb.h liblpsolve55.so
-library LpSolveUtils lp_utils.h liblpsolve55.so
-library LpSolveTypes lp_types.h liblpsolve55.so
-library LpSolveSOS lp_SOS.h liblpsolve55.so

// Include gcc header files
-I/usr/lib/gcc/i686-linux-gnu/4.7/include/

// Output standalone .jar
//-mode StandaloneJar

// Output .java files instead of a .jar
-noJar
// -noJar is buggy so it requires -noComp
-noComp

// Use experimental option to output Scala to current directory
// -scalaOut .

// Verbose output
-v
