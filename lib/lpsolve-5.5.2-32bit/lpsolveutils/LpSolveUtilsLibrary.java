package lpsolveutils;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.DoubleBuffer;
import java.nio.IntBuffer;
import lpsolvelib.lprec;
/**
 * JNA Wrapper for library <b>LpSolveUtils</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class LpSolveUtilsLibrary implements Library {
	public static final String JNA_LIBRARY_NAME = "LpSolveUtils";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(LpSolveUtilsLibrary.JNA_LIBRARY_NAME);
	static {
		Native.register(LpSolveUtilsLibrary.JNA_LIBRARY_NAME);
	}
	/**
	 * Put function headers here<br>
	 * Original signature : <code>char allocCHAR(lprec*, char**, int, unsigned char)</code><br>
	 * <i>native declaration : lp_utils.h:2354</i>
	 */
	public static native byte allocCHAR(lprec lp, PointerByReference ptr, int size, byte clear);
	/**
	 * Original signature : <code>char allocMYBOOL(lprec*, unsigned char**, int, unsigned char)</code><br>
	 * <i>native declaration : lp_utils.h:2356</i>
	 */
	public static native byte allocMYBOOL(lprec lp, PointerByReference ptr, int size, byte clear);
	/**
	 * Original signature : <code>char allocINT(lprec*, int**, int, unsigned char)</code><br>
	 * <i>native declaration : lp_utils.h:2358</i>
	 */
	public static native byte allocINT(lprec lp, PointerByReference ptr, int size, byte clear);
	/**
	 * Original signature : <code>char allocREAL(lprec*, double**, int, unsigned char)</code><br>
	 * <i>native declaration : lp_utils.h:2360</i>
	 */
	public static native byte allocREAL(lprec lp, PointerByReference ptr, int size, byte clear);
	/**
	 * Original signature : <code>char allocLREAL(lprec*, double**, int, unsigned char)</code><br>
	 * <i>native declaration : lp_utils.h:2362</i>
	 */
	public static native byte allocLREAL(lprec lp, PointerByReference ptr, int size, byte clear);
	/**
	 * Original signature : <code>char allocFREE(lprec*, void**)</code><br>
	 * <i>native declaration : lp_utils.h:2364</i>
	 */
	public static native byte allocFREE(lprec lp, PointerByReference ptr);
	/**
	 * Original signature : <code>double* cloneREAL(lprec*, double*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2366</i><br>
	 * @deprecated use the safer methods {@link #cloneREAL(lpsolvelib.lprec, java.nio.DoubleBuffer, int)} and {@link #cloneREAL(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, int)} instead
	 */
	@Deprecated 
	public static native DoubleByReference cloneREAL(lprec lp, DoubleByReference origlist, int size);
	/**
	 * Original signature : <code>double* cloneREAL(lprec*, double*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2366</i>
	 */
	public static native DoubleByReference cloneREAL(lprec lp, DoubleBuffer origlist, int size);
	/**
	 * Original signature : <code>char* cloneMYBOOL(lprec*, unsigned char*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2368</i><br>
	 * @deprecated use the safer methods {@link #cloneMYBOOL(lpsolvelib.lprec, java.nio.ByteBuffer, int)} and {@link #cloneMYBOOL(lpsolvelib.lprec, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	public static native Pointer cloneMYBOOL(lprec lp, Pointer origlist, int size);
	/**
	 * Original signature : <code>char* cloneMYBOOL(lprec*, unsigned char*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2368</i>
	 */
	public static native Pointer cloneMYBOOL(lprec lp, ByteBuffer origlist, int size);
	/**
	 * Original signature : <code>int* cloneINT(lprec*, int*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2370</i><br>
	 * @deprecated use the safer methods {@link #cloneINT(lpsolvelib.lprec, java.nio.IntBuffer, int)} and {@link #cloneINT(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@Deprecated 
	public static native IntByReference cloneINT(lprec lp, IntByReference origlist, int size);
	/**
	 * Original signature : <code>int* cloneINT(lprec*, int*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2370</i>
	 */
	public static native IntByReference cloneINT(lprec lp, IntBuffer origlist, int size);
	/**
	 * Original signature : <code>int comp_bits(unsigned char*, unsigned char*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2372</i><br>
	 * @deprecated use the safer methods {@link #comp_bits(java.nio.ByteBuffer, java.nio.ByteBuffer, int)} and {@link #comp_bits(com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	public static native int comp_bits(Pointer bitarray1, Pointer bitarray2, int items);
	/**
	 * Original signature : <code>int comp_bits(unsigned char*, unsigned char*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2372</i>
	 */
	public static native int comp_bits(ByteBuffer bitarray1, ByteBuffer bitarray2, int items);
	/**
	 * Original signature : <code>workarraysrec* mempool_create(lprec*)</code><br>
	 * <i>native declaration : lp_utils.h:2374</i>
	 */
	public static native workarraysrec mempool_create(lprec lp);
	/**
	 * Original signature : <code>char* mempool_obtainVector(workarraysrec*, int, int)</code><br>
	 * <i>native declaration : lp_utils.h:2376</i>
	 */
	public static native Pointer mempool_obtainVector(workarraysrec mempool, int count, int unitsize);
	/**
	 * Original signature : <code>char mempool_releaseVector(workarraysrec*, char*, unsigned char)</code><br>
	 * <i>native declaration : lp_utils.h:2378</i><br>
	 * @deprecated use the safer methods {@link #mempool_releaseVector(lpsolveutils.workarraysrec, java.nio.ByteBuffer, byte)} and {@link #mempool_releaseVector(lpsolveutils.workarraysrec, com.sun.jna.Pointer, byte)} instead
	 */
	@Deprecated 
	public static native byte mempool_releaseVector(workarraysrec mempool, Pointer memvector, byte forcefree);
	/**
	 * Original signature : <code>char mempool_releaseVector(workarraysrec*, char*, unsigned char)</code><br>
	 * <i>native declaration : lp_utils.h:2378</i>
	 */
	public static native byte mempool_releaseVector(workarraysrec mempool, ByteBuffer memvector, byte forcefree);
	/**
	 * Original signature : <code>char mempool_free(workarraysrec**)</code><br>
	 * <i>native declaration : lp_utils.h:2380</i><br>
	 * @deprecated use the safer method {@link #mempool_free(lpsolveutils.workarraysrec.ByReference[])} instead
	 */
	@Deprecated 
	public static native byte mempool_free(PointerByReference mempool);
	/**
	 * Original signature : <code>char mempool_free(workarraysrec**)</code><br>
	 * <i>native declaration : lp_utils.h:2380</i>
	 */
	public static native byte mempool_free(workarraysrec.ByReference mempool[]);
	/**
	 * Original signature : <code>void roundVector(double*, int, double)</code><br>
	 * <i>native declaration : lp_utils.h:2382</i><br>
	 * @deprecated use the safer methods {@link #roundVector(java.nio.DoubleBuffer, int, double)} and {@link #roundVector(com.sun.jna.ptr.DoubleByReference, int, double)} instead
	 */
	@Deprecated 
	public static native void roundVector(DoubleByReference myvector, int endpos, double roundzero);
	/**
	 * Original signature : <code>void roundVector(double*, int, double)</code><br>
	 * <i>native declaration : lp_utils.h:2382</i>
	 */
	public static native void roundVector(DoubleBuffer myvector, int endpos, double roundzero);
	/**
	 * Original signature : <code>double normalizeVector(double*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2384</i><br>
	 * @deprecated use the safer methods {@link #normalizeVector(java.nio.DoubleBuffer, int)} and {@link #normalizeVector(com.sun.jna.ptr.DoubleByReference, int)} instead
	 */
	@Deprecated 
	public static native double normalizeVector(DoubleByReference myvector, int endpos);
	/**
	 * Original signature : <code>double normalizeVector(double*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2384</i>
	 */
	public static native double normalizeVector(DoubleBuffer myvector, int endpos);
	/**
	 * Original signature : <code>void swapINT(int*, int*)</code><br>
	 * <i>native declaration : lp_utils.h:2386</i><br>
	 * @deprecated use the safer methods {@link #swapINT(java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #swapINT(com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native void swapINT(IntByReference item1, IntByReference item2);
	/**
	 * Original signature : <code>void swapINT(int*, int*)</code><br>
	 * <i>native declaration : lp_utils.h:2386</i>
	 */
	public static native void swapINT(IntBuffer item1, IntBuffer item2);
	/**
	 * Original signature : <code>void swapREAL(double*, double*)</code><br>
	 * <i>native declaration : lp_utils.h:2388</i><br>
	 * @deprecated use the safer methods {@link #swapREAL(java.nio.DoubleBuffer, java.nio.DoubleBuffer)} and {@link #swapREAL(com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native void swapREAL(DoubleByReference item1, DoubleByReference item2);
	/**
	 * Original signature : <code>void swapREAL(double*, double*)</code><br>
	 * <i>native declaration : lp_utils.h:2388</i>
	 */
	public static native void swapREAL(DoubleBuffer item1, DoubleBuffer item2);
	/**
	 * Original signature : <code>void swapPTR(void**, void**)</code><br>
	 * <i>native declaration : lp_utils.h:2390</i>
	 */
	public static native void swapPTR(PointerByReference item1, PointerByReference item2);
	/**
	 * Original signature : <code>double restoreINT(double, double)</code><br>
	 * <i>native declaration : lp_utils.h:2392</i>
	 */
	public static native double restoreINT(double valREAL, double epsilon);
	/**
	 * Original signature : <code>double roundToPrecision(double, double)</code><br>
	 * <i>native declaration : lp_utils.h:2394</i>
	 */
	public static native double roundToPrecision(double value, double precision);
	/**
	 * Original signature : <code>int searchFor(int, int*, int, int, unsigned char)</code><br>
	 * <i>native declaration : lp_utils.h:2396</i><br>
	 * @deprecated use the safer methods {@link #searchFor(int, java.nio.IntBuffer, int, int, byte)} and {@link #searchFor(int, com.sun.jna.ptr.IntByReference, int, int, byte)} instead
	 */
	@Deprecated 
	public static native int searchFor(int target, IntByReference attributes, int size, int offset, byte absolute);
	/**
	 * Original signature : <code>int searchFor(int, int*, int, int, unsigned char)</code><br>
	 * <i>native declaration : lp_utils.h:2396</i>
	 */
	public static native int searchFor(int target, IntBuffer attributes, int size, int offset, byte absolute);
	/**
	 * Original signature : <code>char isINT(lprec*, double)</code><br>
	 * <i>native declaration : lp_utils.h:2398</i>
	 */
	public static native byte isINT(lprec lp, double value);
	/**
	 * Original signature : <code>char isOrigFixed(lprec*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2400</i>
	 */
	public static native byte isOrigFixed(lprec lp, int varno);
	/**
	 * Original signature : <code>void chsign_bounds(double*, double*)</code><br>
	 * <i>native declaration : lp_utils.h:2402</i><br>
	 * @deprecated use the safer methods {@link #chsign_bounds(java.nio.DoubleBuffer, java.nio.DoubleBuffer)} and {@link #chsign_bounds(com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native void chsign_bounds(DoubleByReference lobound, DoubleByReference upbound);
	/**
	 * Original signature : <code>void chsign_bounds(double*, double*)</code><br>
	 * <i>native declaration : lp_utils.h:2402</i>
	 */
	public static native void chsign_bounds(DoubleBuffer lobound, DoubleBuffer upbound);
	/**
	 * Original signature : <code>double rand_uniform(lprec*, double)</code><br>
	 * <i>native declaration : lp_utils.h:2404</i>
	 */
	public static native double rand_uniform(lprec lp, double range);
	/**
	 * Doubly linked list routines<br>
	 * Original signature : <code>int createLink(int, LLrec**, unsigned char*)</code><br>
	 * <i>native declaration : lp_utils.h:2409</i><br>
	 * @deprecated use the safer methods {@link #createLink(int, lpsolveutils.LLrec.ByReference[], java.nio.ByteBuffer)} and {@link #createLink(int, lpsolveutils.LLrec.ByReference[], com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	public static native int createLink(int size, PointerByReference linkmap, Pointer usedpos);
	/**
	 * Doubly linked list routines<br>
	 * Original signature : <code>int createLink(int, LLrec**, unsigned char*)</code><br>
	 * <i>native declaration : lp_utils.h:2409</i>
	 */
	public static native int createLink(int size, LLrec.ByReference linkmap[], ByteBuffer usedpos);
	/**
	 * Doubly linked list routines<br>
	 * Original signature : <code>int createLink(int, LLrec**, unsigned char*)</code><br>
	 * <i>native declaration : lp_utils.h:2409</i>
	 */
	public static native int createLink(int size, LLrec.ByReference linkmap[], Pointer usedpos);
	/**
	 * Original signature : <code>char freeLink(LLrec**)</code><br>
	 * <i>native declaration : lp_utils.h:2411</i><br>
	 * @deprecated use the safer method {@link #freeLink(lpsolveutils.LLrec.ByReference[])} instead
	 */
	@Deprecated 
	public static native byte freeLink(PointerByReference linkmap);
	/**
	 * Original signature : <code>char freeLink(LLrec**)</code><br>
	 * <i>native declaration : lp_utils.h:2411</i>
	 */
	public static native byte freeLink(LLrec.ByReference linkmap[]);
	/**
	 * Original signature : <code>int sizeLink(LLrec*)</code><br>
	 * <i>native declaration : lp_utils.h:2413</i>
	 */
	public static native int sizeLink(LLrec linkmap);
	/**
	 * Original signature : <code>char isActiveLink(LLrec*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2415</i>
	 */
	public static native byte isActiveLink(LLrec linkmap, int itemnr);
	/**
	 * Original signature : <code>int countActiveLink(LLrec*)</code><br>
	 * <i>native declaration : lp_utils.h:2417</i>
	 */
	public static native int countActiveLink(LLrec linkmap);
	/**
	 * Original signature : <code>int countInactiveLink(LLrec*)</code><br>
	 * <i>native declaration : lp_utils.h:2419</i>
	 */
	public static native int countInactiveLink(LLrec linkmap);
	/**
	 * Original signature : <code>int firstActiveLink(LLrec*)</code><br>
	 * <i>native declaration : lp_utils.h:2421</i>
	 */
	public static native int firstActiveLink(LLrec linkmap);
	/**
	 * Original signature : <code>int lastActiveLink(LLrec*)</code><br>
	 * <i>native declaration : lp_utils.h:2423</i>
	 */
	public static native int lastActiveLink(LLrec linkmap);
	/**
	 * Original signature : <code>char appendLink(LLrec*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2425</i>
	 */
	public static native byte appendLink(LLrec linkmap, int newitem);
	/**
	 * Original signature : <code>char insertLink(LLrec*, int, int)</code><br>
	 * <i>native declaration : lp_utils.h:2427</i>
	 */
	public static native byte insertLink(LLrec linkmap, int afteritem, int newitem);
	/**
	 * Original signature : <code>char setLink(LLrec*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2429</i>
	 */
	public static native byte setLink(LLrec linkmap, int newitem);
	/**
	 * Original signature : <code>char fillLink(LLrec*)</code><br>
	 * <i>native declaration : lp_utils.h:2431</i>
	 */
	public static native byte fillLink(LLrec linkmap);
	/**
	 * Original signature : <code>int nextActiveLink(LLrec*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2433</i>
	 */
	public static native int nextActiveLink(LLrec linkmap, int backitemnr);
	/**
	 * Original signature : <code>int prevActiveLink(LLrec*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2435</i>
	 */
	public static native int prevActiveLink(LLrec linkmap, int forwitemnr);
	/**
	 * Original signature : <code>int firstInactiveLink(LLrec*)</code><br>
	 * <i>native declaration : lp_utils.h:2437</i>
	 */
	public static native int firstInactiveLink(LLrec linkmap);
	/**
	 * Original signature : <code>int lastInactiveLink(LLrec*)</code><br>
	 * <i>native declaration : lp_utils.h:2439</i>
	 */
	public static native int lastInactiveLink(LLrec linkmap);
	/**
	 * Original signature : <code>int nextInactiveLink(LLrec*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2441</i>
	 */
	public static native int nextInactiveLink(LLrec linkmap, int backitemnr);
	/**
	 * Original signature : <code>int prevInactiveLink(LLrec*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2443</i>
	 */
	public static native int prevInactiveLink(LLrec linkmap, int forwitemnr);
	/**
	 * Original signature : <code>int removeLink(LLrec*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2445</i>
	 */
	public static native int removeLink(LLrec linkmap, int itemnr);
	/**
	 * Original signature : <code>LLrec* cloneLink(LLrec*, int, unsigned char)</code><br>
	 * <i>native declaration : lp_utils.h:2447</i>
	 */
	public static native LLrec cloneLink(LLrec sourcemap, int newsize, byte freesource);
	/**
	 * Original signature : <code>int compareLink(LLrec*, LLrec*)</code><br>
	 * <i>native declaration : lp_utils.h:2449</i>
	 */
	public static native int compareLink(LLrec linkmap1, LLrec linkmap2);
	/**
	 * Original signature : <code>char verifyLink(LLrec*, int, unsigned char)</code><br>
	 * <i>native declaration : lp_utils.h:2451</i>
	 */
	public static native byte verifyLink(LLrec linkmap, int itemnr, byte doappend);
	/**
	 * Packed vector routines<br>
	 * Original signature : <code>PVrec* createPackedVector(int, double*, int*)</code><br>
	 * <i>native declaration : lp_utils.h:2456</i><br>
	 * @deprecated use the safer methods {@link #createPackedVector(int, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #createPackedVector(int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native PVrec createPackedVector(int size, DoubleByReference values, IntByReference workvector);
	/**
	 * Packed vector routines<br>
	 * Original signature : <code>PVrec* createPackedVector(int, double*, int*)</code><br>
	 * <i>native declaration : lp_utils.h:2456</i>
	 */
	public static native PVrec createPackedVector(int size, DoubleBuffer values, IntBuffer workvector);
	/**
	 * Original signature : <code>void pushPackedVector(PVrec*, PVrec*)</code><br>
	 * <i>native declaration : lp_utils.h:2458</i>
	 */
	public static native void pushPackedVector(PVrec PV, PVrec parent);
	/**
	 * Original signature : <code>char unpackPackedVector(PVrec*, double**)</code><br>
	 * <i>native declaration : lp_utils.h:2460</i>
	 */
	public static native byte unpackPackedVector(PVrec PV, PointerByReference target);
	/**
	 * Original signature : <code>double getvaluePackedVector(PVrec*, int)</code><br>
	 * <i>native declaration : lp_utils.h:2462</i>
	 */
	public static native double getvaluePackedVector(PVrec PV, int index);
	/**
	 * Original signature : <code>PVrec* popPackedVector(PVrec*)</code><br>
	 * <i>native declaration : lp_utils.h:2464</i>
	 */
	public static native PVrec popPackedVector(PVrec PV);
	/**
	 * Original signature : <code>char freePackedVector(PVrec**)</code><br>
	 * <i>native declaration : lp_utils.h:2466</i><br>
	 * @deprecated use the safer method {@link #freePackedVector(lpsolveutils.PVrec.ByReference[])} instead
	 */
	@Deprecated 
	public static native byte freePackedVector(PointerByReference PV);
	/**
	 * Original signature : <code>char freePackedVector(PVrec**)</code><br>
	 * <i>native declaration : lp_utils.h:2466</i>
	 */
	public static native byte freePackedVector(PVrec.ByReference PV[]);
}
