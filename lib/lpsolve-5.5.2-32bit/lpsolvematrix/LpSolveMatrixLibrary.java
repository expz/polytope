package lpsolvematrix;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.DoubleBuffer;
import java.nio.IntBuffer;
import lpsolvelib.LpSolveLibLibrary.WINAPI;
import lpsolvelib.lprec;
import lpsolveutils.LLrec;
/**
 * JNA Wrapper for library <b>LpSolveMatrix</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class LpSolveMatrixLibrary implements Library {
	public static final String JNA_LIBRARY_NAME = "LpSolveMatrix";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(LpSolveMatrixLibrary.JNA_LIBRARY_NAME);
	static {
		Native.register(LpSolveMatrixLibrary.JNA_LIBRARY_NAME);
	}
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int matValueStep = (int)1;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int MatrixRowAccess = (int)0;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int MAT_ROUNDABSREL = (int)(1 + 2);
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int MAT_ROUNDABS = (int)1;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int matRowColStep = (int)1;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final double MAT_ROUNDRCMIN = (double)1.0;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int MatrixColAccess = (int)1;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int RAM_Index = (int)0;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int CAM_Record = (int)0;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int MAT_ROUNDDEFAULT = (int)2;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int MAT_ROUNDNONE = (int)0;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int MAT_ROUNDREL = (int)2;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int MAT_ROUNDRC = (int)4;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int CAM_Vector = (int)1;
	/** <i>native declaration : lp_matrix.h</i> */
	public static final int RAM_FullCopy = (int)1;
	/**
	 * Sparse matrix routines<br>
	 * Original signature : <code>MATrec* mat_create(lprec*, int, int, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2540</i>
	 */
	public static native MATrec mat_create(lprec lp, int rows, int columns, double epsvalue);
	/**
	 * Original signature : <code>char mat_memopt(MATrec*, int, int, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2542</i>
	 */
	public static native byte mat_memopt(MATrec mat, int rowextra, int colextra, int nzextra);
	/**
	 * Original signature : <code>void mat_free(MATrec**)</code><br>
	 * <i>native declaration : lp_matrix.h:2544</i><br>
	 * @deprecated use the safer method {@link #mat_free(lpsolvematrix.MATrec.ByReference[])} instead
	 */
	@Deprecated 
	public static native void mat_free(PointerByReference matrix);
	/**
	 * Original signature : <code>void mat_free(MATrec**)</code><br>
	 * <i>native declaration : lp_matrix.h:2544</i>
	 */
	public static native void mat_free(MATrec.ByReference matrix[]);
	/**
	 * Original signature : <code>char inc_matrow_space(MATrec*, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2546</i>
	 */
	public static native byte inc_matrow_space(MATrec mat, int deltarows);
	/**
	 * Original signature : <code>int mat_mapreplace(MATrec*, LLrec*, LLrec*, MATrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2548</i>
	 */
	public static native int mat_mapreplace(MATrec mat, LLrec rowmap, LLrec colmap, MATrec insmat);
	/**
	 * Original signature : <code>int mat_matinsert(MATrec*, MATrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2550</i>
	 */
	public static native int mat_matinsert(MATrec mat, MATrec insmat);
	/**
	 * Original signature : <code>int mat_zerocompact(MATrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2552</i>
	 */
	public static native int mat_zerocompact(MATrec mat);
	/**
	 * Original signature : <code>int mat_rowcompact(MATrec*, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2554</i>
	 */
	public static native int mat_rowcompact(MATrec mat, byte dozeros);
	/**
	 * Original signature : <code>int mat_colcompact(MATrec*, int, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2556</i>
	 */
	public static native int mat_colcompact(MATrec mat, int prev_rows, int prev_cols);
	/**
	 * Original signature : <code>char inc_matcol_space(MATrec*, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2558</i>
	 */
	public static native byte inc_matcol_space(MATrec mat, int deltacols);
	/**
	 * Original signature : <code>char inc_mat_space(MATrec*, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2560</i>
	 */
	public static native byte inc_mat_space(MATrec mat, int mindelta);
	/**
	 * Original signature : <code>int mat_shiftrows(MATrec*, int*, int, LLrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2562</i><br>
	 * @deprecated use the safer methods {@link #mat_shiftrows(lpsolvematrix.MATrec, java.nio.IntBuffer, int, lpsolveutils.LLrec)} and {@link #mat_shiftrows(lpsolvematrix.MATrec, com.sun.jna.ptr.IntByReference, int, lpsolveutils.LLrec)} instead
	 */
	@Deprecated 
	public static native int mat_shiftrows(MATrec mat, IntByReference bbase, int delta, LLrec varmap);
	/**
	 * Original signature : <code>int mat_shiftrows(MATrec*, int*, int, LLrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2562</i>
	 */
	public static native int mat_shiftrows(MATrec mat, IntBuffer bbase, int delta, LLrec varmap);
	/**
	 * Original signature : <code>int mat_shiftcols(MATrec*, int*, int, LLrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2564</i><br>
	 * @deprecated use the safer methods {@link #mat_shiftcols(lpsolvematrix.MATrec, java.nio.IntBuffer, int, lpsolveutils.LLrec)} and {@link #mat_shiftcols(lpsolvematrix.MATrec, com.sun.jna.ptr.IntByReference, int, lpsolveutils.LLrec)} instead
	 */
	@Deprecated 
	public static native int mat_shiftcols(MATrec mat, IntByReference bbase, int delta, LLrec varmap);
	/**
	 * Original signature : <code>int mat_shiftcols(MATrec*, int*, int, LLrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2564</i>
	 */
	public static native int mat_shiftcols(MATrec mat, IntBuffer bbase, int delta, LLrec varmap);
	/**
	 * Original signature : <code>MATrec* mat_extractmat(MATrec*, LLrec*, LLrec*, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2566</i>
	 */
	public static native MATrec mat_extractmat(MATrec mat, LLrec rowmap, LLrec colmap, byte negated);
	/**
	 * Original signature : <code>int mat_appendrow(MATrec*, int, double*, int*, double, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2568</i><br>
	 * @deprecated use the safer methods {@link #mat_appendrow(lpsolvematrix.MATrec, int, java.nio.DoubleBuffer, java.nio.IntBuffer, double, byte)} and {@link #mat_appendrow(lpsolvematrix.MATrec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, double, byte)} instead
	 */
	@Deprecated 
	public static native int mat_appendrow(MATrec mat, int count, DoubleByReference row, IntByReference colno, double mult, byte checkrowmode);
	/**
	 * Original signature : <code>int mat_appendrow(MATrec*, int, double*, int*, double, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2568</i>
	 */
	public static native int mat_appendrow(MATrec mat, int count, DoubleBuffer row, IntBuffer colno, double mult, byte checkrowmode);
	/**
	 * Original signature : <code>int mat_appendcol(MATrec*, int, double*, int*, double, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2570</i><br>
	 * @deprecated use the safer methods {@link #mat_appendcol(lpsolvematrix.MATrec, int, java.nio.DoubleBuffer, java.nio.IntBuffer, double, byte)} and {@link #mat_appendcol(lpsolvematrix.MATrec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, double, byte)} instead
	 */
	@Deprecated 
	public static native int mat_appendcol(MATrec mat, int count, DoubleByReference column, IntByReference rowno, double mult, byte checkrowmode);
	/**
	 * Original signature : <code>int mat_appendcol(MATrec*, int, double*, int*, double, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2570</i>
	 */
	public static native int mat_appendcol(MATrec mat, int count, DoubleBuffer column, IntBuffer rowno, double mult, byte checkrowmode);
	/**
	 * Original signature : <code>char mat_get_data(lprec*, int, unsigned char, int**, int**, double**)</code><br>
	 * <i>native declaration : lp_matrix.h:2572</i>
	 */
	public static native byte mat_get_data(lprec lp, int matindex, byte isrow, PointerByReference rownr, PointerByReference colnr, PointerByReference value);
	/**
	 * Original signature : <code>char mat_set_rowmap(MATrec*, int, int, int, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2574</i>
	 */
	public static native byte mat_set_rowmap(MATrec mat, int row_mat_index, int rownr, int colnr, int col_mat_index);
	/**
	 * Original signature : <code>char mat_indexrange(MATrec*, int, unsigned char, int*, int*)</code><br>
	 * <i>native declaration : lp_matrix.h:2576</i><br>
	 * @deprecated use the safer methods {@link #mat_indexrange(lpsolvematrix.MATrec, int, byte, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #mat_indexrange(lpsolvematrix.MATrec, int, byte, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native byte mat_indexrange(MATrec mat, int index, byte isrow, IntByReference startpos, IntByReference endpos);
	/**
	 * Original signature : <code>char mat_indexrange(MATrec*, int, unsigned char, int*, int*)</code><br>
	 * <i>native declaration : lp_matrix.h:2576</i>
	 */
	public static native byte mat_indexrange(MATrec mat, int index, byte isrow, IntBuffer startpos, IntBuffer endpos);
	/**
	 * Original signature : <code>char mat_validate(MATrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2578</i>
	 */
	public static native byte mat_validate(MATrec mat);
	/**
	 * Original signature : <code>char mat_equalRows(MATrec*, int, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2580</i>
	 */
	public static native byte mat_equalRows(MATrec mat, int baserow, int comprow);
	/**
	 * Original signature : <code>int mat_findelm(MATrec*, int, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2582</i>
	 */
	public static native int mat_findelm(MATrec mat, int row, int column);
	/**
	 * Original signature : <code>int mat_findins(MATrec*, int, int, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2584</i><br>
	 * @deprecated use the safer methods {@link #mat_findins(lpsolvematrix.MATrec, int, int, java.nio.IntBuffer, byte)} and {@link #mat_findins(lpsolvematrix.MATrec, int, int, com.sun.jna.ptr.IntByReference, byte)} instead
	 */
	@Deprecated 
	public static native int mat_findins(MATrec mat, int row, int column, IntByReference insertpos, byte validate);
	/**
	 * Original signature : <code>int mat_findins(MATrec*, int, int, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2584</i>
	 */
	public static native int mat_findins(MATrec mat, int row, int column, IntBuffer insertpos, byte validate);
	/**
	 * Original signature : <code>void mat_multcol(MATrec*, int, double, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2586</i>
	 */
	public static native void mat_multcol(MATrec mat, int col_nr, double mult, byte DoObj);
	/**
	 * Original signature : <code>double mat_getitem(MATrec*, int, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2588</i>
	 */
	public static native double mat_getitem(MATrec mat, int row, int column);
	/**
	 * Original signature : <code>char mat_setitem(MATrec*, int, int, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2590</i>
	 */
	public static native byte mat_setitem(MATrec mat, int row, int column, double value);
	/**
	 * Original signature : <code>char mat_additem(MATrec*, int, int, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2592</i>
	 */
	public static native byte mat_additem(MATrec mat, int row, int column, double delta);
	/**
	 * Original signature : <code>char mat_setvalue(MATrec*, int, int, double, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2594</i>
	 */
	public static native byte mat_setvalue(MATrec mat, int Row, int Column, double Value, byte doscale);
	/**
	 * Original signature : <code>int mat_nonzeros(MATrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2596</i>
	 */
	public static native int mat_nonzeros(MATrec mat);
	/**
	 * Original signature : <code>int mat_collength(MATrec*, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2598</i>
	 */
	public static native int mat_collength(MATrec mat, int colnr);
	/**
	 * Original signature : <code>int mat_rowlength(MATrec*, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2600</i>
	 */
	public static native int mat_rowlength(MATrec mat, int rownr);
	/**
	 * Original signature : <code>void mat_multrow(MATrec*, int, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2602</i>
	 */
	public static native void mat_multrow(MATrec mat, int row_nr, double mult);
	/**
	 * Original signature : <code>void mat_multadd(MATrec*, double*, int, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2604</i><br>
	 * @deprecated use the safer methods {@link #mat_multadd(lpsolvematrix.MATrec, java.nio.DoubleBuffer, int, double)} and {@link #mat_multadd(lpsolvematrix.MATrec, com.sun.jna.ptr.DoubleByReference, int, double)} instead
	 */
	@Deprecated 
	public static native void mat_multadd(MATrec mat, DoubleByReference lhsvector, int varnr, double mult);
	/**
	 * Original signature : <code>void mat_multadd(MATrec*, double*, int, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2604</i>
	 */
	public static native void mat_multadd(MATrec mat, DoubleBuffer lhsvector, int varnr, double mult);
	/**
	 * Original signature : <code>char mat_setrow(MATrec*, int, int, double*, int*, unsigned char, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2606</i><br>
	 * @deprecated use the safer methods {@link #mat_setrow(lpsolvematrix.MATrec, int, int, java.nio.DoubleBuffer, java.nio.IntBuffer, byte, byte)} and {@link #mat_setrow(lpsolvematrix.MATrec, int, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, byte, byte)} instead
	 */
	@Deprecated 
	public static native byte mat_setrow(MATrec mat, int rowno, int count, DoubleByReference row, IntByReference colno, byte doscale, byte checkrowmode);
	/**
	 * Original signature : <code>char mat_setrow(MATrec*, int, int, double*, int*, unsigned char, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2606</i>
	 */
	public static native byte mat_setrow(MATrec mat, int rowno, int count, DoubleBuffer row, IntBuffer colno, byte doscale, byte checkrowmode);
	/**
	 * Original signature : <code>char mat_setcol(MATrec*, int, int, double*, int*, unsigned char, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2608</i><br>
	 * @deprecated use the safer methods {@link #mat_setcol(lpsolvematrix.MATrec, int, int, java.nio.DoubleBuffer, java.nio.IntBuffer, byte, byte)} and {@link #mat_setcol(lpsolvematrix.MATrec, int, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, byte, byte)} instead
	 */
	@Deprecated 
	public static native byte mat_setcol(MATrec mat, int colno, int count, DoubleByReference column, IntByReference rowno, byte doscale, byte checkrowmode);
	/**
	 * Original signature : <code>char mat_setcol(MATrec*, int, int, double*, int*, unsigned char, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2608</i>
	 */
	public static native byte mat_setcol(MATrec mat, int colno, int count, DoubleBuffer column, IntBuffer rowno, byte doscale, byte checkrowmode);
	/**
	 * Original signature : <code>char mat_mergemat(MATrec*, MATrec*, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2610</i>
	 */
	public static native byte mat_mergemat(MATrec target, MATrec source, byte usecolmap);
	/**
	 * Original signature : <code>int mat_checkcounts(MATrec*, int*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2612</i><br>
	 * @deprecated use the safer methods {@link #mat_checkcounts(lpsolvematrix.MATrec, java.nio.IntBuffer, java.nio.IntBuffer, byte)} and {@link #mat_checkcounts(lpsolvematrix.MATrec, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference, byte)} instead
	 */
	@Deprecated 
	public static native int mat_checkcounts(MATrec mat, IntByReference rownum, IntByReference colnum, byte freeonexit);
	/**
	 * Original signature : <code>int mat_checkcounts(MATrec*, int*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2612</i>
	 */
	public static native int mat_checkcounts(MATrec mat, IntBuffer rownum, IntBuffer colnum, byte freeonexit);
	/**
	 * Original signature : <code>int mat_expandcolumn(MATrec*, int, double*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2614</i><br>
	 * @deprecated use the safer methods {@link #mat_expandcolumn(lpsolvematrix.MATrec, int, java.nio.DoubleBuffer, java.nio.IntBuffer, byte)} and {@link #mat_expandcolumn(lpsolvematrix.MATrec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, byte)} instead
	 */
	@Deprecated 
	public static native int mat_expandcolumn(MATrec mat, int colnr, DoubleByReference column, IntByReference nzlist, byte signedA);
	/**
	 * Original signature : <code>int mat_expandcolumn(MATrec*, int, double*, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2614</i>
	 */
	public static native int mat_expandcolumn(MATrec mat, int colnr, DoubleBuffer column, IntBuffer nzlist, byte signedA);
	/**
	 * Original signature : <code>char mat_computemax(MATrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2616</i>
	 */
	public static native byte mat_computemax(MATrec mat);
	/**
	 * Original signature : <code>char mat_transpose(MATrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2618</i>
	 */
	public static native byte mat_transpose(MATrec mat);
	/**
	 * Original signature : <code>WINAPI invert(lprec*, unsigned char, unsigned final char)</code><br>
	 * <i>native declaration : lp_matrix.h:2620</i>
	 */
	public static native WINAPI invert(lprec lp, byte shiftbounds, byte char1);
	/**
	 * Vector compression and expansion routines<br>
	 * Original signature : <code>char vec_compress(double*, int, int, double, double*, int*)</code><br>
	 * <i>native declaration : lp_matrix.h:2625</i><br>
	 * @deprecated use the safer methods {@link #vec_compress(java.nio.DoubleBuffer, int, int, double, java.nio.DoubleBuffer, java.nio.IntBuffer)} and {@link #vec_compress(com.sun.jna.ptr.DoubleByReference, int, int, double, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	public static native byte vec_compress(DoubleByReference densevector, int startpos, int endpos, double epsilon, DoubleByReference nzvector, IntByReference nzindex);
	/**
	 * Vector compression and expansion routines<br>
	 * Original signature : <code>char vec_compress(double*, int, int, double, double*, int*)</code><br>
	 * <i>native declaration : lp_matrix.h:2625</i>
	 */
	public static native byte vec_compress(DoubleBuffer densevector, int startpos, int endpos, double epsilon, DoubleBuffer nzvector, IntBuffer nzindex);
	/**
	 * Original signature : <code>char vec_expand(double*, int*, double*, int, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2627</i><br>
	 * @deprecated use the safer methods {@link #vec_expand(java.nio.DoubleBuffer, java.nio.IntBuffer, java.nio.DoubleBuffer, int, int)} and {@link #vec_expand(com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.DoubleByReference, int, int)} instead
	 */
	@Deprecated 
	public static native byte vec_expand(DoubleByReference nzvector, IntByReference nzindex, DoubleByReference densevector, int startpos, int endpos);
	/**
	 * Original signature : <code>char vec_expand(double*, int*, double*, int, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2627</i>
	 */
	public static native byte vec_expand(DoubleBuffer nzvector, IntBuffer nzindex, DoubleBuffer densevector, int startpos, int endpos);
	/**
	 * Sparse matrix products<br>
	 * Original signature : <code>char get_colIndexA(lprec*, int, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2632</i><br>
	 * @deprecated use the safer methods {@link #get_colIndexA(lpsolvelib.lprec, int, java.nio.IntBuffer, byte)} and {@link #get_colIndexA(lpsolvelib.lprec, int, com.sun.jna.ptr.IntByReference, byte)} instead
	 */
	@Deprecated 
	public static native byte get_colIndexA(lprec lp, int varset, IntByReference colindex, byte append);
	/**
	 * Sparse matrix products<br>
	 * Original signature : <code>char get_colIndexA(lprec*, int, int*, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2632</i>
	 */
	public static native byte get_colIndexA(lprec lp, int varset, IntBuffer colindex, byte append);
	/**
	 * Original signature : <code>int prod_Ax(lprec*, int*, double*, int*, double, double, double*, int*, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2634</i><br>
	 * @deprecated use the safer methods {@link #prod_Ax(lpsolvelib.lprec, java.nio.IntBuffer, java.nio.DoubleBuffer, java.nio.IntBuffer, double, double, java.nio.DoubleBuffer, java.nio.IntBuffer, int)} and {@link #prod_Ax(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, double, double, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@Deprecated 
	public static native int prod_Ax(lprec lp, IntByReference coltarget, DoubleByReference input, IntByReference nzinput, double roundzero, double ofscalar, DoubleByReference output, IntByReference nzoutput, int roundmode);
	/**
	 * Original signature : <code>int prod_Ax(lprec*, int*, double*, int*, double, double, double*, int*, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2634</i>
	 */
	public static native int prod_Ax(lprec lp, IntBuffer coltarget, DoubleBuffer input, IntBuffer nzinput, double roundzero, double ofscalar, DoubleBuffer output, IntBuffer nzoutput, int roundmode);
	/**
	 * Original signature : <code>int prod_xA(lprec*, int*, double*, int*, double, double, double*, int*, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2636</i><br>
	 * @deprecated use the safer methods {@link #prod_xA(lpsolvelib.lprec, java.nio.IntBuffer, java.nio.DoubleBuffer, java.nio.IntBuffer, double, double, java.nio.DoubleBuffer, java.nio.IntBuffer, int)} and {@link #prod_xA(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, double, double, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@Deprecated 
	public static native int prod_xA(lprec lp, IntByReference coltarget, DoubleByReference input, IntByReference nzinput, double roundzero, double ofscalar, DoubleByReference output, IntByReference nzoutput, int roundmode);
	/**
	 * Original signature : <code>int prod_xA(lprec*, int*, double*, int*, double, double, double*, int*, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2636</i>
	 */
	public static native int prod_xA(lprec lp, IntBuffer coltarget, DoubleBuffer input, IntBuffer nzinput, double roundzero, double ofscalar, DoubleBuffer output, IntBuffer nzoutput, int roundmode);
	/**
	 * Original signature : <code>char prod_xA2(lprec*, int*, double*, double, int*, double*, double, int*, double, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2638</i><br>
	 * @deprecated use the safer methods {@link #prod_xA2(lpsolvelib.lprec, java.nio.IntBuffer, java.nio.DoubleBuffer, double, java.nio.IntBuffer, java.nio.DoubleBuffer, double, java.nio.IntBuffer, double, int)} and {@link #prod_xA2(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.DoubleByReference, double, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.DoubleByReference, double, com.sun.jna.ptr.IntByReference, double, int)} instead
	 */
	@Deprecated 
	public static native byte prod_xA2(lprec lp, IntByReference coltarget, DoubleByReference prow, double proundzero, IntByReference pnzprow, DoubleByReference drow, double droundzero, IntByReference dnzdrow, double ofscalar, int roundmode);
	/**
	 * Original signature : <code>char prod_xA2(lprec*, int*, double*, double, int*, double*, double, int*, double, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2638</i>
	 */
	public static native byte prod_xA2(lprec lp, IntBuffer coltarget, DoubleBuffer prow, double proundzero, IntBuffer pnzprow, DoubleBuffer drow, double droundzero, IntBuffer dnzdrow, double ofscalar, int roundmode);
	/**
	 * Equation solution<br>
	 * Original signature : <code>char fimprove(lprec*, double*, int*, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2643</i><br>
	 * @deprecated use the safer methods {@link #fimprove(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.IntBuffer, double)} and {@link #fimprove(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, double)} instead
	 */
	@Deprecated 
	public static native byte fimprove(lprec lp, DoubleByReference pcol, IntByReference nzidx, double roundzero);
	/**
	 * Equation solution<br>
	 * Original signature : <code>char fimprove(lprec*, double*, int*, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2643</i>
	 */
	public static native byte fimprove(lprec lp, DoubleBuffer pcol, IntBuffer nzidx, double roundzero);
	/**
	 * Original signature : <code>void ftran(lprec*, double*, int*, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2645</i><br>
	 * @deprecated use the safer methods {@link #ftran(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.IntBuffer, double)} and {@link #ftran(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, double)} instead
	 */
	@Deprecated 
	public static native void ftran(lprec lp, DoubleByReference rhsvector, IntByReference nzidx, double roundzero);
	/**
	 * Original signature : <code>void ftran(lprec*, double*, int*, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2645</i>
	 */
	public static native void ftran(lprec lp, DoubleBuffer rhsvector, IntBuffer nzidx, double roundzero);
	/**
	 * Original signature : <code>char bimprove(lprec*, double*, int*, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2647</i><br>
	 * @deprecated use the safer methods {@link #bimprove(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.IntBuffer, double)} and {@link #bimprove(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, double)} instead
	 */
	@Deprecated 
	public static native byte bimprove(lprec lp, DoubleByReference rhsvector, IntByReference nzidx, double roundzero);
	/**
	 * Original signature : <code>char bimprove(lprec*, double*, int*, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2647</i>
	 */
	public static native byte bimprove(lprec lp, DoubleBuffer rhsvector, IntBuffer nzidx, double roundzero);
	/**
	 * Original signature : <code>void btran(lprec*, double*, int*, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2649</i><br>
	 * @deprecated use the safer methods {@link #btran(lpsolvelib.lprec, java.nio.DoubleBuffer, java.nio.IntBuffer, double)} and {@link #btran(lpsolvelib.lprec, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, double)} instead
	 */
	@Deprecated 
	public static native void btran(lprec lp, DoubleByReference rhsvector, IntByReference nzidx, double roundzero);
	/**
	 * Original signature : <code>void btran(lprec*, double*, int*, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2649</i>
	 */
	public static native void btran(lprec lp, DoubleBuffer rhsvector, IntBuffer nzidx, double roundzero);
	/**
	 * Combined equation solution and matrix product for simplex operations<br>
	 * Original signature : <code>char fsolve(lprec*, int, double*, int*, double, double, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2654</i><br>
	 * @deprecated use the safer methods {@link #fsolve(lpsolvelib.lprec, int, java.nio.DoubleBuffer, java.nio.IntBuffer, double, double, byte)} and {@link #fsolve(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, double, double, byte)} instead
	 */
	@Deprecated 
	public static native byte fsolve(lprec lp, int varin, DoubleByReference pcol, IntByReference nzidx, double roundzero, double ofscalar, byte prepareupdate);
	/**
	 * Combined equation solution and matrix product for simplex operations<br>
	 * Original signature : <code>char fsolve(lprec*, int, double*, int*, double, double, unsigned char)</code><br>
	 * <i>native declaration : lp_matrix.h:2654</i>
	 */
	public static native byte fsolve(lprec lp, int varin, DoubleBuffer pcol, IntBuffer nzidx, double roundzero, double ofscalar, byte prepareupdate);
	/**
	 * Original signature : <code>char bsolve(lprec*, int, double*, int*, double, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2656</i><br>
	 * @deprecated use the safer methods {@link #bsolve(lpsolvelib.lprec, int, java.nio.DoubleBuffer, java.nio.IntBuffer, double, double)} and {@link #bsolve(lpsolvelib.lprec, int, com.sun.jna.ptr.DoubleByReference, com.sun.jna.ptr.IntByReference, double, double)} instead
	 */
	@Deprecated 
	public static native byte bsolve(lprec lp, int row_nr, DoubleByReference rhsvector, IntByReference nzidx, double roundzero, double ofscalar);
	/**
	 * Original signature : <code>char bsolve(lprec*, int, double*, int*, double, double)</code><br>
	 * <i>native declaration : lp_matrix.h:2656</i>
	 */
	public static native byte bsolve(lprec lp, int row_nr, DoubleBuffer rhsvector, IntBuffer nzidx, double roundzero, double ofscalar);
	/**
	 * Original signature : <code>void bsolve_xA2(lprec*, int*, int, double*, double, int*, int, double*, double, int*, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2658</i><br>
	 * @deprecated use the safer methods {@link #bsolve_xA2(lpsolvelib.lprec, java.nio.IntBuffer, int, java.nio.DoubleBuffer, double, java.nio.IntBuffer, int, java.nio.DoubleBuffer, double, java.nio.IntBuffer, int)} and {@link #bsolve_xA2(lpsolvelib.lprec, com.sun.jna.ptr.IntByReference, int, com.sun.jna.ptr.DoubleByReference, double, com.sun.jna.ptr.IntByReference, int, com.sun.jna.ptr.DoubleByReference, double, com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@Deprecated 
	public static native void bsolve_xA2(lprec lp, IntByReference coltarget, int row_nr1, DoubleByReference vector1, double roundzero1, IntByReference nzvector1, int row_nr2, DoubleByReference vector2, double roundzero2, IntByReference nzvector2, int roundmode);
	/**
	 * Original signature : <code>void bsolve_xA2(lprec*, int*, int, double*, double, int*, int, double*, double, int*, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2658</i>
	 */
	public static native void bsolve_xA2(lprec lp, IntBuffer coltarget, int row_nr1, DoubleBuffer vector1, double roundzero1, IntBuffer nzvector1, int row_nr2, DoubleBuffer vector2, double roundzero2, IntBuffer nzvector2, int roundmode);
	/**
	 * Change-tracking routines (primarily for B&B and presolve)<br>
	 * Original signature : <code>DeltaVrec* createUndoLadder(lprec*, int, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2663</i>
	 */
	public static native DeltaVrec createUndoLadder(lprec lp, int levelitems, int maxlevels);
	/**
	 * Original signature : <code>int incrementUndoLadder(DeltaVrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2665</i>
	 */
	public static native int incrementUndoLadder(DeltaVrec DV);
	/**
	 * Original signature : <code>char modifyUndoLadder(DeltaVrec*, int, double[], double)</code><br>
	 * <i>native declaration : lp_matrix.h:2667</i><br>
	 * @deprecated use the safer methods {@link #modifyUndoLadder(lpsolvematrix.DeltaVrec, int, java.nio.DoubleBuffer, double)} and {@link #modifyUndoLadder(lpsolvematrix.DeltaVrec, int, com.sun.jna.ptr.DoubleByReference, double)} instead
	 */
	@Deprecated 
	public static native byte modifyUndoLadder(DeltaVrec DV, int itemno, DoubleByReference target, double newvalue);
	/**
	 * Original signature : <code>char modifyUndoLadder(DeltaVrec*, int, double[], double)</code><br>
	 * <i>native declaration : lp_matrix.h:2667</i>
	 */
	public static native byte modifyUndoLadder(DeltaVrec DV, int itemno, DoubleBuffer target, double newvalue);
	/**
	 * Original signature : <code>int countsUndoLadder(DeltaVrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2669</i>
	 */
	public static native int countsUndoLadder(DeltaVrec DV);
	/**
	 * Original signature : <code>int restoreUndoLadder(DeltaVrec*, double[])</code><br>
	 * <i>native declaration : lp_matrix.h:2671</i><br>
	 * @deprecated use the safer methods {@link #restoreUndoLadder(lpsolvematrix.DeltaVrec, java.nio.DoubleBuffer)} and {@link #restoreUndoLadder(lpsolvematrix.DeltaVrec, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	public static native int restoreUndoLadder(DeltaVrec DV, DoubleByReference target);
	/**
	 * Original signature : <code>int restoreUndoLadder(DeltaVrec*, double[])</code><br>
	 * <i>native declaration : lp_matrix.h:2671</i>
	 */
	public static native int restoreUndoLadder(DeltaVrec DV, DoubleBuffer target);
	/**
	 * Original signature : <code>int decrementUndoLadder(DeltaVrec*)</code><br>
	 * <i>native declaration : lp_matrix.h:2673</i>
	 */
	public static native int decrementUndoLadder(DeltaVrec DV);
	/**
	 * Original signature : <code>char freeUndoLadder(DeltaVrec**)</code><br>
	 * <i>native declaration : lp_matrix.h:2675</i><br>
	 * @deprecated use the safer method {@link #freeUndoLadder(lpsolvematrix.DeltaVrec.ByReference[])} instead
	 */
	@Deprecated 
	public static native byte freeUndoLadder(PointerByReference DV);
	/**
	 * Original signature : <code>char freeUndoLadder(DeltaVrec**)</code><br>
	 * <i>native declaration : lp_matrix.h:2675</i>
	 */
	public static native byte freeUndoLadder(DeltaVrec.ByReference DV[]);
	/**
	 * Specialized presolve undo functions<br>
	 * Original signature : <code>char appendUndoPresolve(lprec*, unsigned char, double, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2680</i>
	 */
	public static native byte appendUndoPresolve(lprec lp, byte isprimal, double beta, int colnrDep);
	/**
	 * Original signature : <code>char addUndoPresolve(lprec*, unsigned char, int, double, double, int)</code><br>
	 * <i>native declaration : lp_matrix.h:2682</i>
	 */
	public static native byte addUndoPresolve(lprec lp, byte isprimal, int colnrElim, double alpha, double beta, int colnrDep);
}
